---
title: "Nature in 2040"
subtitle: "Forecasting Human Modification of Global Lands from 2020 to 2040"
author: "Glenn Moncrieff, Maria Voigt, Christina Kennedy - Global Science TNC <br> Jim Oakleaf, Joe Kiesecker - Global Protect TNC"
date: "2025-08-19"
format:
  revealjs:
    theme: simple
    slide-number: true

    # ↓↓↓ add these two lines
    scrollable: true     # allow the page itself to scroll
    center: false        # start content at the top, not vertically centred
    include-in-header: header.html
output-file: index.html
---

## Global Human Modification explained

<div style="font-size:0.5em">
 The Global Human Modification (HM) index [Theobald et al 2024](https://www.nature.com/articles/s41597-025-04892-2) measures the impact of human activities on nature by quantifying the distribution and intensity of 14 threats globally. It ranges from 0 (no human impact) to 1 (maximum human impact). These 14 threats are summarized into a single cumulative index representing the overall impact of human activities on nature. A time series of this index is available from 1990 to 2020 every 5 years at 300m resolution for both the individual threats and the cumulative index. 

[![](/images/hm1.png)](https://www.nature.com/articles/s41597-025-04892-2)
</div>

## Why and how to forecast Human Modification
<div style="font-size:0.5em">
Forecasts of human impacts help us anticipate where and when pressures on ecosystems are likely to intensify, allowing proactive rather than reactive action. By linking projected changes to planning, they guide decisions on where to prioritize protection, restoration, or policy interventions for the greatest long-term benefit.
<br>
![Impact](/images/impact1.png) <br>
But forecasting human impacts is not easy. There is a trade-off between the level of detail in the forecast and the uncertainty/accuracy of the forecast.
<br>

**High detail - actionable but hard to predict**<br>
Will a specific 300m pixel be converted to housing between 2095 and 2100?<br>
_How much will it rain in my neighborhood park on the 3rd Monday in July in 2028_<br><br>

**Medium detail - informative and somewhat predictable**<br>
Overall change in human pressure at 1km resolution between 2020 and 2040<br>
_Likelihood the maximum monthly temperature in July 2050 in Denver will exceed 90F /32C in 2050_<br><br>

**Low detail - less useful but more predictable**<br>
Overall pressure at Country scale in 2030<br>
_The global average temperature in 2030_<br><br>

Recognizing this trade-off, we do not attempt to forecast HM at fine scale or far into the future. Instead, we focus on forecasting HM at 1km resolution for the period 2020-2040. 
</div>

## Forecasting methodology
<div style="font-size:0.5em">
The forecasts presented here build directly on the Global Human Modification (HM) time series. Using this historical HM record, we produce global, 1-km resolution forecasts of overall HM from 2020 to 2040 and provide calibrated uncertainty intervals for each forecast horizon. These layers offer plausible trajectories of cumulative human pressure that are consistent with observed patterns and rates in the underlying HM time series. They allow planners and decision makers to consider where cumulative human pressures—not just conversion—are likely to intensify, enabling threat-aware, forward-looking prioritisation. We use a multi-horizon forecast approach to predict human modification at every 5 year interval from 2020 to 2040. We use a range of covariates to predict human modification, including population, economic development, and infrastructure development. The multi-horizon approach allows us to forecast human modification at different time horizons, from short-term (5 year) to long-term (20 year). 
<br><br>
Potential reuse includes: <br><br>

- risk-based site selection for protected and conserved areas and other area-based measures aligned with GBF Target 1

- prospective evaluation of conservation additionality by comparing observed threat outcomes to expected trajectories

- integration as pressure inputs to biodiversity impact models (e.g., GLOBIO) and ecosystem-condition indicators

- screening in spatial planning and environmental assessment where forward-looking pressure maps can complement land-use scenarios.

</div>

## Model description
<div style="font-size:0.5em">

### Overview

The overall structure of the model is to process both static and dynamic covariates along with historical HM data through a Convolutional Long Short-Term Memory network (ConvLSTM) deep learning architecture, which learns spatio-temporal patterns directly from the gridded data. This deep learning approach simultaneously predicts future HM at multiple time horizons (5, 10, 15, and 20 years) with uncertainty estimates. For instance, when trained on data up to 2020, the model can generate predictions for the central tendency, upper and lower quantiles for 2025, 2030, 2035, and 2040. 
<br><br>
Important to note is that we do not use development scenarios or narratives to drive forecasts. Rather, models are trained on historical data and then used to predict the future. This can be thought of as using a business-as-usual scenario to drive the forecast. But business as usual is not solely based on an individual site's history, but learned from trying to predict the observed development of other sites with similar histories/covariates.
<br><br>
![](/images/hm_model2.gif){style="width:300%"}

### Model covariates
<br>
_Static covariates_

- **Protected areas (WDPA)** 

Global polygons/points of protected and conserved areas from WDPA are used to derive two binary raster layers: (i) “strictly protected” (IUCN categories Ia, Ib, II) and (ii) “other protected” (all other IUCN categories). 

- **Climate (CHELSA)** 

Mean annual temperature, mean annual precipitation, and minimum temperature of the coldest month are derived from the monthly mean, max, mean temperature, and mean precipitation values from CHELSA. 

- **Topography**  

EarthENv provides cross-scale topographic data derived primarily from GMTED2010/SRTM and aggregated to standardized 1 km products. We use 1km resolution elevation data in this analysis.

- **Location**  

Geographic coordinates are encoded using real spherical-harmonic basis functions following [Russwurm et al 2024](https://arxiv.org/abs/2310.06743). This means we encode each pixel’s latitude/longitude by projecting it onto a small set of smooth, globe “wave” patterns, so every place gets a stable, seam-free location fingerprint defined directly on the sphere. Compared other approiachs to representing coordinates as features in a model, spherical harmonics avoid artifacts at the dateline and poles because they are well-defined everywhere on the globe. Low orders capture only broad gradients (e.g., pole-to-equator), and increasing the order (L) adds finer spatial detail. Including location directly as covariates in the model captures unmeasured location-specific factors (cultural, political, economic contexts).
![](/images/location.png)

- **Development Pressure**  
 The Development Suitability Index (DSI) is a per-pixel metric ranging from 0 (least suitable) to 1 (most suitable) for assessing the potential for land development (Oakleaf 2024). It is constructed by first calculating multiple underlying development potential indices (DPIs), then combining them via an average multiplied by the maximum DPI value at each location.  <br>
  ![](/images/dsi.png) [Oakleaf et al 2024](https://www.nature.com/articles/s41597-024-03639-9) 

_Dynamic covariates_

- **Human Modification**  
HM itself and its component threats are also used as covariates. We use lagged overall HM for three historical time steps e.g. if predicting 2020 HM overall, data for 1990, 1995 and 2000 will be used as covariates when training a model for a 20 year forecast horizon. If predicting 2020 but training a model to predict over a 5 year forecast horizon, data for 2015, 2010 and 2005 will be used. We also difference these lags and add these differences as covariates. Finally we use the last observed HM components threat data e.g. If predicting 2020 with a 5 year forecast horizon model, HM component threats for 2015 are used as covariates. 

- **Population** 

We use a 1 km global gridded population dataset spanning 1870–2100 at 10-year steps (Zhuang et al. 2024); for this model we subset 1990–2020. The series provides coherent historical and SSP-consistent future distributions. For the historical period, they relied on observed population maps (2000–2020) and applied statistical modeling methods to hindcast population distributions. Their approach involved using known population patterns from more recent decades to infer earlier distributions, ensuring spatial coherence and temporal consistency across time. The calculation of HM does not directly incorporate population data, and hence these data are not already explicitly included through HM covariates. 

- **GDP** 

We use gridded GDP projections compatible with the five SSPs from Murakami et al (2021). Data are available at ~10 km grids for 10-year steps from 1850–2100. Here we subset 1990–2020. The historical GDP data was downscaled to a ~10 km resolution via a spatial econometric downscaling model. Starting  with national-level historical GDP figures, a model is used  redistributed GDP across the grid. The model explicitly accounts for spatial and economic interactions among cities, along with a range of auxiliary geographic data—for example, road networks, land cover, and other urban context variables.  

### Data splitting
The data splitting process begins by creating a validity mask from the raw Human Modification (HM) data, marking pixels as valid (1) if they are not NaN and have HM values ≥ 0, and invalid (0) otherwise. The valid data is then divided into non-overlapping 128km x128km pixel chips, with only those containing at least 20% valid pixels retained. These chips are split into training (70%), validation (10%), test (10%), and calibration (10%) sets using spatial blocking to prevent data leakage between geographically adjacent areas. The validation set was used to assess model performance when tuning settings, the calibration set was used to calibrate uncertainty, and the testing set was used only once to estimate the accuracy of the final model. The image below shows how this partitioning would work over the globe <br>. The model is trained to predict multiple time horizons (5, 10, 15, and 20 years ahead) simultaneously. For training, it uses a flexible temporal sampling approach where it randomly selects an end year (from 2000, 2005, 2010, or 2015) and uses the three most recent 5-year intervals as input (e.g., for end year 2020, it would use 1990, 1995, and 2000 as input) to predict the next 20 years (2005, 2010, 2015, 2020). For test and validating, the model uses the same approach on unseen geographic regions.

![](/images/split.png)
### Model objectives and uncertainty
The model's objective is carefully designed to address the challenges of predicting human modification (HM) changes, where most pixels show little to no change over time while a few experience significant changes. If we relied solely on mean squared error (MSE), the model would be biased toward predicting no change, as this would minimize the average error across the predominantly stable landscape. This is particularly problematic because the most ecologically significant changes are often the rarest and most consequential, such as rapid urbanization or deforestation, which the model might fail to capture if it only aims to minimize average error.

To overcome this, the model attmpepts to simultaneously optimise three complementary objectives that work together to balance different aspects of prediction quality - mean pixel error (mse), spatial patterns and regional hisorgrams of change magnitudes. The MSE ensures pixel-level accuracy, particularly for the magnitude of changes. The spatial objective works to maintain realistic spatial patterns and sharpness in the predictions, preventing blurry or unrealistic spatial configurations. Finally, the histogram objective ensures that the distribution of predicted change magnitudes across each tile matches the expected distribution, which is crucial for capturing the frequency of rare but important large changes. 

The model also provides uncertainty estimates through quantile predictions, which are essential for decision-making in conservation and land-use planning. These predictions help identify areas where the model is less certain, flagging regions that might require additional monitoring or where predictions should be interpreted with caution. By training separate heads for the central prediction and quantile bounds, the model can provide both accurate central estimates and well-calibrated uncertainty intervals, making it more reliable and interpretable for real-world applications.

### Model fitting and software

The project uses PyTorch for deep learning, with PyTorch Lightning for streamlined training workflows. It leverages rasterio for geospatial data handling and integrates Weights & Biases (W&B) for experiment tracking and visualization. The codebase is organized using Python's standard libraries and follows a modular structure with custom implementations for the ConvLSTM architecture, loss functions, and data loading. The project uses conda for environment management and includes scripts for data preprocessing, model training, and evaluation, with a focus on reproducibility through fixed random seeds and version control.
</div>

## Model performance and accuracy
<div style="font-size:0.5em">
Comparing the fitted models against baseline assumptions - In the absence of a model, we might assume either the status quo (zero change) or a linear trend. How does our model compare to these baselines over different horizons? In the figure below, ‘Multihorizon’ represents the median prediction from the multihorizon model, ‘Zero’ assumes that future HM does not change from the last observed HM. ‘Linear’ assumes HM continues to increase at the same rate observed between the last 2 observations. <br>
 ![](/images/horizon.png)
<br>
 Assuming that 5 years from now will be the same as now is a hard baseline to beat, but as we go further into the future, the model becomes better. It is never a great idea to assume that the change we last observed will continue in the future. 

 <br><br>
 How well can we predict HM in 20 years' time? The figure below shows modeled vs observed HM with a 20-year forecast horizon (i.e. predicting 2020 with data up to 2000). HM is scaled by 10,000 (i.e. 1,000 = 0.1 HM, 10,000 = 1 HM). 
 <br><br> 
 ![](/images/abs_err.png) 
<br><br>
Very well!  
<br><br>
 But remember, just assuming it will not change works pretty well, so predicting the absolute value is not that hard.
 <br><br>
 How well can we predict how much HM will change in 20 years' time? Below we see modeled vs observed HM change over a 20-year forecast horizon (i.e. predicting change from 2000 to 2020 with data from 1990 to 2000). Again, HM is scaled by 10,000. 
 <br><br> 
 ![](/images/diff_err.png)  
 <br><br> It is hard, but we get the overall direction and magnitude right.
 <br><br>
</div>

## Comparing predictions to observations

<div style="font-size:0.5em">
What do individual pixels look like? Below we see how HM predicted from 2005 to 2020 based on data from 1990-2000, comparing predictions to observations. We see some in which it is quite certain they will remain intact and not change (first panel), some that are high and expected to remain stable (second panel), some that are expected to remain intact, but where loss of condition is a potential outcome (third panel), and lastly, we also see examples where a large change is observed, but the median prediction does not capture this. However, the wide uncertainty band indicates that the model does not rule out this outcome (fourth panel). Including uncertainty captures the range of possible outcomes and helps us understand the risk of different scenarios.
 <br><br>
![](/images/timeseries.png)
  <br><br>
Large changes in HM or major industrial development are rare events. It is not unexpected that the model rarely predicted this to be the most likely outcome. What is encouraging is that the model helps us map where we cannot rule out that there will be a large change in the future. Likewise, areas with little uncertainty are those where we are very confident about the future. We might not always get the mean prediction correct - this is a very hard problem to predict. But we can get well-calibrated ranges so that we are 95% certain the true outcome will lie within these bounds. 
</div>

## Focal areas - Maps of predicted change and uncertainty

<div style="font-size:0.5em">
Below are some examples of regions of interest that highlight current HM and predicted changes between 2020 and 2040. Interactive maps allowing full exploration of the data are available on subsequent slides.
 <br><br>
legend for HM images:<br>
![](/images/leg.png)

### Brazil - Mato Grosso
In Mato Grosso, Brazil, large areas of Amazon forest and Cerrado savanna have been cleared over the past two decades, mainly for cattle pasture and increasingly for soybean cultivation.
![Mato Grosso](/images/am_ar.png)
<br>

#### Observed HM in 2020

<iframe frameborder="0" class="juxtapose" width="100%" height="579.3003618817853" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=1430f122-9476-11f0-ba1b-0e6f42328d7d"></iframe>
<br>

#### Observed HM in 2020 vs Predicted HM in 2040
<iframe frameborder="0" class="juxtapose" width="100%" height="583.2946859903382" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=e2e26070-9479-11f0-ba1b-0e6f42328d7d"></iframe>

<br>
HM is predicted to increasingly broadly across the deforestation frontier; however, we do not predict that deforestation or very large increases in HM are the most likely outcome. Even at the deforestation frontier, forest loss over a 20-year period is rarely more likely than not. However, the predicted HM increases indicate that the model agrees that this region is at risk of deforestation.
<br>

#### Median HM in 2040 vs upper 95% confidence limit

<iframe frameborder="0" class="juxtapose" width="100%" height="583.2938331318018" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=70378e0e-948a-11f0-ba1b-0e6f42328d7d"></iframe>

<br>
 
When we look at the upper 95% confidence limit, we see that the model predicted that a very wide area is at risk of severe increases in HM. This highlights the challenge of predicting rare events that result in large changes in HM, like deforestation. In the historical data, these changes appear common, but they are still less likely than stasis, even in areas at high risk. The model therefore predicts a moderate increase in HM that balances the risk of deforestation with the risk of not deforesting. In these cases, it is more informative to look at the upper 95% confidence limit to understand if drastic change is within the range of possible outcomes.
<br>

#### Predicted intact / natural lands in 2040 based on lower, median, or upper band predictions.

<br>

![](/images/int_leg.png)
<br>
<iframe frameborder="0" class="juxtapose" width="100%" height="641" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=033f6af0-9495-11f0-ba1b-0e6f42328d7d"></iframe>
<br>
We can define a threshold HM value above which we may believe lands can no longer be assumed to be natural. Here we choose 0.1 HM as the threshold, and map the extent of intact lands in 2040 and intact lands lost between 2020 and 2040 based on HM modeled at different confidence levels. Orange indicates that loss of natural lands between 2020 and 2040 is the most likely outcome, pink indicates that loss is possible under the worst-case (upper 95%) scenario, and purple indicates that land remains intact in 2040 even in the worst-case scenario.
<br>

### Yucatán Peninsula
In the Yucatán Peninsula, forest cover is being lost mostly around expanding agriculture, pasture, and urban/tourism development. Drivers include changing land tenure, proximity to roads and markets, soil fertility, and economic incentives and government programs for agricultural intensification.
![Yucatán Peninsula](/images/sm_ar.png)
<br>

#### Observed HM in 2020

<iframe frameborder="0" class="juxtapose" width="100%" height="506.99999999999994" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=db3585c4-9487-11f0-ba1b-0e6f42328d7d"></iframe>
<br>

#### Observed HM in 2020 vs Predicted HM in 2040

<iframe frameborder="0" class="juxtapose" width="100%" height="506.99999999999994" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=12690e44-9488-11f0-ba1b-0e6f42328d7d"></iframe>
<br>
Despite deforestation and development occurring in many regions of the Yucatán Peninsula in the historical period, in the median forecast there is little large-scale change predicted. Some areas around major urban centers and the agricultural frontier show modest increases in HM.

#### Median HM in 2040 vs upper 95% confidence limit
<br>

<iframe frameborder="0" class="juxtapose" width="100%" height="506.99999999999994" src="https://cdn.knightlab.com/libs/juxtapose/latest/embed/index.html?uid=edc71b1a-9489-11f0-ba1b-0e6f42328d7d"></iframe>
<br>

The upper 95% confidence limit highlights the potential for agricultural intensification and further development around existing frontiers, demonstrating that though not the most likely outcome, vast areas are at risk. 
<br>
This result may seem counter to our understanding of risk in this landscape. Sure, there is risk of further deforestation, but it is not possible that all of this area will be degraded by 2040. An important point to understand is that these maps show per pixel uncertainty. The model is not saying that there is a chance that all of this area will be deforested simultaneously by 2040, but rather that for each of the highlighted pixels independently, there is a chance. A useful analogy for this is rolling dice. If you roll one die, there is a 1/6 chance you will get a 6, but if you roll 1000 dice, there is an almost 0% chance all will be 6s. 

#### Predicted intact / natural lands in 2040 based on lower, median, or upper band predictions.

<br>
![](/images/int_leg.png)
<br>
As in the example of Mato Grosso, large regions are shown as at risk of loss of natural lands in the worst-case scenario. A relatively small area is at risk of loss of natural lands in the median scenario. A distinct spatial pattern is also apparent, with regions in the south and west of the image experiencing greater loss of natural land in the worst-case scenario. 
<br>

</div>

## Applications of these data
<div style="font-size:0.5em">

There are multiple existing global datasets that provide information on conversion risk, typically through forecasts of future land cover (look out for a forthcoming paper from our team comparing these). There are also an array of tools that allow you to create your own local land cover forecasts if you have a series of historical land cover data and driver variables. You may be familiar with a TNC product called the Conversion Pressure Index (CPI) which combines information on past changes in HM with maps of future development pressure to estimate the potential for land conversion.
<br>
<br>
The Human Modification forecasts we provide here go beyond these existing datasets and allow for a number of more nuanced analyses and deeper consideration of threats to biodiversity. This is principally because we do not just provide a prediction of where natural habitats will be converted but rather estimate a continuous metric of human pressure. We attempt to predict not only when wholesale conversion of natural habitats will occur but also when minor loss of condition in pristine environments will occur. We can also predict if a moderately modified habitat will undergo further intensification. This is important because even a minor increase in human pressure through, for example, increased human intrusion into a habitat may result in a cascade of ecological changes that results in a significant loss of biodiversity. Likewise, a moderately modified habitat may still accommodate a diversity of species and allow for a range of ecological processes to continue, but this can be threatened by further intensification. Forecasts that only predict wholesale land conversion cannot capture this nuance.
<br>
<br>
In addition, most forecast models do not account for uncertainty in their predictions. While it is common practice to use multiple development scenarios (e.g., SSPs), this leaves most uncertainty unaccounted for, as even given a set development trajectory, there are many ways development could unfold. Our forecasts use historical patterns to estimate the per-pixel uncertainty in future human modification. As our results show, rarely is severe degradation the most likely outcome. Rather, there is a limited area directly at the frontier of development where this is true, but large swathes of land are at low-to-medium risk of HM intensification. This is important information for conservation decision-making. The level of risk to nature that is acceptable is a decision that must be made in light of multiple other factors such as biodiversity value, ecosystem services, and social and economic factors. If we only account for the location where wholesale change is the most likely outcome, we vastly underestimate the risk.

<br>
<br>
Below are some examples to illustrate these points and insights that can be gained

#### Example from Yucatan Peninsula

Below is a point in the core of the Balam Kin Wildlife Protection Area. This intact forest ecosystem has experienced little human modification to date, and forecasts show that this is unlikely to change in the near term. Importantly, the upper forecast band is also very low, indicating that even under a pessimistic scenario, this area is not at risk of severe degradation.

<br>
![](/images/stable_ts.png)
<br>

In an area of rapid development with historical patterns of deforestation south-west of Campeche, a location that is currently forested and not developed is predicted to remain undeveloped in the median forecast, but the upper forecast shows that this area is at risk of severe degradation in the worst-case scenario. This illustrates how even in areas of rapid development often the most likely outcome is stasis. However, there remain high risks, and this is demonstrated by the upper forecast band.

<br>
![](/images/uncertain_ts.png)
<br>

Lastly, a location in the southern fringe of Merida that has already been somewhat modified in recent decades is predicted to undergo further intensification even in the median forecast, with the upper band indicating the possibility of intensive development.

<br>
![](/images/increase_ts.png)
<br>

</div>

## Known artefacts 
<div style="font-size:0.5em">
These results should be considered preliminary and subject to change as the model is refined and validated. We are aware of a number of issues and artifacts described below:

### 1. Striping near the poles 

Example from Siberia: 
<br>
![](/images/pole.png)
<br>
Most likely cause is encoding of lat/long using spherical harmonics. Potential fix is to increase harmonic order, change the way we encode lat/long, or simply remove lat/long covariates. 

### 2. Hexagonal patterns introduced by H3 gridding 

Example from the Amazon basin: 
<br>
![](/images/hex.png)
<br>
Caused by H3 covariates and reflects the underlying hexagonal structure of neighborhoods. Potential fix is to use a more complex neighborhood calculation, but this will greatly increase model runtime. 

### 3. Prediction bands decreasing over time 
<br>
![](/images/band.png)
<br>
We would expect prediction bands to only increase over time. Potential cause is conformal adjustment. Need to check if original, uncalibrated prediction bands do or do not show this pattern. 

</div>

## Globe (Mapbox + WMS) {data-visibility="hidden"}

```{=html}
<link href="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.css" rel="stylesheet" />
<div id="mb-globe-wrap" style="position:relative;">
  <div id="mb-globe" style="height: 500px; margin-top: 1rem;"></div>
  <!-- Layer toggle controls: Panel 1 -->
  <div id="mb-layer-controls-1" style="position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; font-size:14px; box-shadow:0 1px 4px rgba(0,0,0,0.2); min-width: 220px;">
    <div style="font-weight:700; margin-bottom:6px;">Human Modification Index</div>
    <div style="font-weight:600; margin-bottom:4px;">Year</div>
    <div style="margin-bottom:6px;">
      <select id="mb-year-1" style="width:100%;">
        <option value="1990-01-01">1990</option>
        <option value="1995-01-01">1995</option>
        <option value="2000-01-01">2000</option>
        <option value="2005-01-01">2005</option>
        <option value="2010-01-01">2010</option>
        <option value="2015-01-01">2015</option>
        <option value="2020-01-01">2020</option>
        <option value="2025-01-01">2025</option>
        <option value="2030-01-01">2030</option>
        <option value="2035-01-01">2035</option>
        <option value="2040-01-01">2040</option>
      </select>
    </div>
    <div style="border-top: 1px solid #ddd; margin:6px 0;"></div>
    <div style="font-weight:600; margin-bottom:4px;">Quantile</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-upper" value="upper" checked> <span>upper</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-middle" value="middle"> <span>middle</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-lower" value="lower"> <span>lower</span></label>
    </div>
    <div style="margin-top:6px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <span>Opacity</span>
        <input type="range" id="mb-opacity-1" min="0" max="1" step="0.05" value="1">
        <span id="mb-opacity-1-val">1.00</span>
      </label>
    </div>
  </div>
  <!-- Layer toggle controls: Panel 2 -->
  <div id="mb-layer-controls-2" style="position:absolute; right:10px; top:170px; z-index:999; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; font-size:14px; box-shadow:0 1px 4px rgba(0,0,0,0.2); min-width: 220px;">
    <div style="font-weight:700; margin-bottom:6px;">Human Modification Index</div>
    <div style="font-weight:600; margin-bottom:4px;">Year</div>
    <div style="margin-bottom:6px;">
      <select id="mb-year-2" style="width:100%;">
        <option value="1990-01-01">1990</option>
        <option value="1995-01-01">1995</option>
        <option value="2000-01-01">2000</option>
        <option value="2005-01-01">2005</option>
        <option value="2010-01-01">2010</option>
        <option value="2015-01-01">2015</option>
        <option value="2020-01-01">2020</option>
        <option value="2025-01-01">2025</option>
        <option value="2030-01-01">2030</option>
        <option value="2035-01-01">2035</option>
        <option value="2040-01-01">2040</option>
      </select>
    </div>
    <div style="border-top: 1px solid #ddd; margin:6px 0;"></div>
    <div style="font-weight:600; margin-bottom:4px;">Quantile</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-upper" value="upper" checked> <span>upper</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-middle" value="middle"> <span>middle</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-lower" value="lower"> <span>lower</span></label>
    </div>
    <div style="margin-top:6px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <span>Opacity</span>
        <input type="range" id="mb-opacity-2" min="0" max="1" step="0.05" value="0">
        <span id="mb-opacity-2-val">0.00</span>
      </label>
    </div>
  </div>
  
  <!-- Click coords readout -->
  <div id="mb-coords" style="margin-top: 8px; font-size: 13px; color:#333;">
    Click on the globe to see lon/lat here.
  </div>
  <div id="mb-edr" style="margin-top: 6px; font-size: 12px; color:#333; white-space: pre-wrap;"></div>
  <!-- Air through time chart -->
  <div id="air-chart-wrap" style="height: 220px; margin-top: 8px; background: #fff; border: 1px solid #eee; border-radius: 4px; padding: 6px;">
    <canvas id="air-chart" height="200"></canvas>
  </div>
  
</div>
```

<link href="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.js"></script>
<!-- Chart.js + date adapter for time scale -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js"></script>
<script>
  let mbGlobeInited = false;
  // Chart instance holder
  let airChart = null;
  function initMbGlobe() {
    if (mbGlobeInited) return;
    mbGlobeInited = true;

    // Expect token set globally as window.MAPBOX_TOKEN; no hardcoded fallback
    if (window.MAPBOX_TOKEN) {
      mapboxgl.accessToken = window.MAPBOX_TOKEN;
    } else {
      console.warn('Mapbox token missing. Set MAPBOX_TOKEN env var before rendering the Mapbox globe slide.');
    }

    const map = new mapboxgl.Map({
      container: 'mb-globe',
      style: 'mapbox://styles/mapbox/satellite-streets-v12',
      zoom: 1,
      center: [-74.5447, 40.6892],
      attributionControl: true
    });

    // Show last-clicked lon/lat under the globe and drop/update a marker
    const coordEl = document.getElementById('mb-coords');
    function fmt(n) { return (Math.round(n * 10000) / 10000).toFixed(4); }
    if (coordEl) {
      map.on('click', (e) => {
        const { lng, lat } = e.lngLat;
        coordEl.textContent = `Lon: ${fmt(lng)}, Lat: ${fmt(lat)}`;
        // Update click-point GeoJSON source if present
        const src = map.getSource('click-point');
        if (src) {
          src.setData({
            type: 'FeatureCollection',
            features: [
              {
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [lng, lat] },
                properties: {}
              }
            ]
          });
        }

        // Fetch EDR for three quantiles and plot together
        const edrEl = document.getElementById('mb-edr');
        if (edrEl) {
          // Show a lightweight spinner while fetching
          if (!document.getElementById('edr-spinner-style')) {
            const style = document.createElement('style');
            style.id = 'edr-spinner-style';
            style.textContent = `
              .edr-spinner { display:inline-block; width:14px; height:14px; border:2px solid rgba(0,0,0,0.15); border-top-color: rgba(0,0,0,0.6); border-radius:50%; animation: edr-spin 0.8s linear infinite; vertical-align:middle; }
              @keyframes edr-spin { to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);
          }
          edrEl.innerHTML = '<span class="edr-spinner" aria-label="Loading" title="Loading"></span>';
          const coordsWKT = `POINT(${lng} ${lat})`;
          const makeUrl = (param) => `https://compute.earthmover.io/v1/services/edr/the-nature-conservancy/hm-multitemp/main/hm/edr/position?coords=${encodeURIComponent(coordsWKT)}&parameter-name=${param}`;
          const paramsList = ['upper','middle','lower'];
          Promise.all(paramsList.map(p => fetch(makeUrl(p)).then(r => r.json()).then(data => ({ p, data })).catch(err => ({ p, error: err }))))
            .then(results => {
              // Collect points per param within date window
              const colors = { upper: '#e41a1c', middle: '#377eb8', lower: '#4daf4a' };
              const series = { upper: [], middle: [], lower: [] };
              const START_MS = Date.parse('1990-01-01');
              const CUTOVER_MS = Date.parse('2020-01-01');
              const END_MS = Date.parse('2040-01-01');
              let firstText = '';
              results.forEach(({ p, data, error }) => {
                if (error || !data || !series[p]) return;
                const dates = data?.domain?.axes?.date?.values || data?.domain?.axes?.t?.values || [];
                const vals = data?.ranges?.[p]?.values || [];
                if (Array.isArray(dates) && Array.isArray(vals) && dates.length && vals.length) {
                  series[p] = dates
                    .map((d, i) => ({ x: Date.parse(d), y: vals[i] }))
                    .filter(pt => Number.isFinite(pt.x) && Number.isFinite(pt.y) && pt.x >= START_MS && pt.x <= END_MS);
                  if (!firstText) firstText = `Date: ${dates[0]}  •  ${p}: ${vals[0]}`;
                }
              });
              // Stop showing spinner regardless of whether data was found
              edrEl.innerHTML = '';

              // Build datasets: shaded 95% confidence (upper to lower), plus middle as observed/predicted
              // Make the confidence band converge to a single point at the last observed year (CUTOVER_MS)
              // using the middle series value at CUTOVER_MS, then expand from first forecast year (e.g., 2025).
              const lastObservedMiddle = [...series.middle]
                .filter(pt => pt.x <= CUTOVER_MS)
                .sort((a,b) => a.x - b.x)
                .slice(-1)[0];
              const cutY = lastObservedMiddle ? lastObservedMiddle.y : null;
              let lowerBand = series.lower.filter(pt => pt.x >= CUTOVER_MS);
              let upperBand = series.upper.filter(pt => pt.x >= CUTOVER_MS);
              if (cutY !== null) {
                lowerBand = [{ x: CUTOVER_MS, y: cutY }, ...lowerBand];
                upperBand = [{ x: CUTOVER_MS, y: cutY }, ...upperBand];
              }
              const lowerDs = {
                label: '', // no label; hide from legend/tooltip
                data: lowerBand,
                borderColor: 'transparent',
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 0,
                tension: 0.2,
                fill: false
              };
              const bandDs = {
                label: '95% confidence',
                data: upperBand,
                borderColor: 'transparent',
                backgroundColor: (colors.upper || '#e41a1c') + '33',
                pointRadius: 0,
                borderWidth: 0,
                tension: 0.2,
                fill: '-1' // fill to previous dataset (lower)
              };
              // Split middle into observed (<=2020-01-01) and predicted (>=2020-01-01)
              let observed = series.middle.map(pt => (pt.x <= CUTOVER_MS ? pt : { x: pt.x, y: null }));
              let predicted = series.middle.filter(pt => pt.x >= CUTOVER_MS);
              // Add bridging point at CUTOVER_MS so lines meet without a gap
              const prevPt = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
              const hasCutoverObserved = observed.some(pt => pt.x === CUTOVER_MS && pt.y !== null);
              const hasCutoverPred = predicted.some(pt => pt.x === CUTOVER_MS);
              if (prevPt) {
                const bridge = { x: CUTOVER_MS, y: prevPt.y };
                if (!hasCutoverObserved) observed = [...observed.filter(pt => pt.x < CUTOVER_MS), bridge, ...observed.filter(pt => pt.x > CUTOVER_MS)];
                if (!hasCutoverPred) predicted = [bridge, ...predicted];
              }
              // Ensure arrays sorted by x and nulls removed from predicted
              observed.sort((a,b) => a.x - b.x);
              predicted.sort((a,b) => a.x - b.x);
              const observedDs = {
                label: 'observed',
                data: observed,
                borderColor: colors.middle,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [],
                tension: 0.2,
                fill: false
              };
              const predictedDs = {
                label: 'predicted',
                data: predicted,
                borderColor: colors.middle,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [6, 4],
                tension: 0.2,
                fill: false
              };
              const datasets = [lowerDs, bandDs, observedDs, predictedDs];

              // Build or update Chart.js
              const ctx = document.getElementById('air-chart');
              if (ctx && window.Chart) {
                // Destroy any existing chart on this canvas before creating a new one
                try {
                  const existing = (window.Chart.getChart ? window.Chart.getChart(ctx) : window.airChart);
                  if (existing) existing.destroy();
                } catch (e) { console.warn('Chart destroy warning:', e); }

                window.airChart = new Chart(ctx, {
                  type: 'line',
                  data: { datasets },
                  options: {
                    maintainAspectRatio: false,
                    parsing: false,
                    spanGaps: true,
                    scales: {
                      x: {
                        type: 'linear',
                        title: { display: true, text: 'Date' },
                        min: START_MS,
                        max: END_MS,
                        ticks: {
                          callback: (v) => { try { return new Date(v).toISOString().slice(0,16).replace('T',' '); } catch { return v; } },
                          maxTicksLimit: 6
                        }
                      },
                      y: { title: { display: true, text: 'Human Modification Index' } }
                    },
                    plugins: {
                      legend: {
                        display: true,
                        labels: {
                          filter: (item) => !!item.text
                        }
                      },
                      tooltip: {
                        callbacks: {
                          label: (ctx) => {
                            const label = ctx.dataset && typeof ctx.dataset.label === 'string' ? ctx.dataset.label : '';
                            if (!label || label.startsWith('_')) return null; // hide helper/empty labels
                            const x = ctx.parsed.x; const y = ctx.parsed.y;
                            const ts = new Date(x).toISOString().slice(0,19).replace('T',' ');
                            return ` ${label}: ${y}  •  ${ts}`;
                          }
                        }
                      }
                    }
                  }
                });
              }
            })
            .catch(err => {
              // Hide spinner and log error, but do not show UI text
              edrEl.innerHTML = '';
              console.error('EDR error:', err);
            });
        }
      });
    }

    map.on('style.load', () => {
      // Switch to globe projection
      if (map.setProjection) {
        map.setProjection('globe');
      }

      // Build WMS URL from PARAM and YEAR selections
      const buildWmsUrl = (param, year) => {
        const base = 'https://compute.earthmover.io/v1/services/wms/the-nature-conservancy/hm-multitemp/main/hm/wms?version=1.3.0&service=WMS&request=GetMap&layers=PARAM&styles=raster/default&colorscalerange=0,1&width=512&height=512&crs=EPSG:3857&date=YEAR&tile={x},{y},{z}';
        return base.replace('PARAM', param).replace('YEAR', year);
      };

      // Insert below labels/buildings if present
      const beforeId = map.getStyle().layers.find(l => ['building','road-label','poi-label','place-label'].includes(l.id))?.id;

      // IDs for PARAM sources/layers
      const params = ['lower','middle','upper']; // bottom-first for stacking
      const srcId = (panel, p) => `wms-${panel}-${p}-src`;
      const lyrId = (panel, p) => `wms-${panel}-${p}-layer`;

      // Helper to (re)create a source+layer for a given panel, param and year
      function upsertParam(panel, param, year, opacity) {
        if (map.getLayer(lyrId(panel, param))) map.removeLayer(lyrId(panel, param));
        if (map.getSource(srcId(panel, param))) map.removeSource(srcId(panel, param));
        const url = buildWmsUrl(param, year);
        console.log(`[WMS] panel=${panel} param=${param} year=${year} url=`, url);
        map.addSource(srcId(panel, param), {
          type: 'raster',
          tiles: [ url ],
          tileSize: 256
        });
        map.addLayer({
          id: lyrId(panel, param),
          type: 'raster',
          source: srcId(panel, param),
          paint: { 'raster-opacity': opacity }
        }, beforeId);
      }

      // Initial creation for both panels based on current UI selections
      const yearSel1 = document.getElementById('mb-year-1');
      const yearSel2 = document.getElementById('mb-year-2');
      const opacity1El = document.getElementById('mb-opacity-1');
      const opacity2El = document.getElementById('mb-opacity-2');
      const op1 = opacity1El ? parseFloat(opacity1El.value) : 1.0;
      const op2 = opacity2El ? parseFloat(opacity2El.value) : 0.0;
      const yearVal1 = yearSel1 ? yearSel1.value : '1990-01-01';
      const yearVal2 = yearSel2 ? yearSel2.value : '1990-01-01';
      params.forEach(p => upsertParam(1, p, yearVal1, op1));
      params.forEach(p => upsertParam(2, p, yearVal2, op2));

      // Wire up PARAM radios per panel to enforce single selection and toggle visibility
      function setOnly(panel, param) {
        params.forEach(p => {
          const id = lyrId(panel, p);
          if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', p === param ? 'visible' : 'none');
        });
      }
      const paramRadios1 = Array.from(document.querySelectorAll('input[name="mb-param-1"]'));
      const paramRadios2 = Array.from(document.querySelectorAll('input[name="mb-param-2"]'));
      paramRadios1.forEach(r => r.addEventListener('change', () => setOnly(1, r.value)));
      paramRadios2.forEach(r => r.addEventListener('change', () => setOnly(2, r.value)));
      // Initial vis sync: show selected radio only per panel
      const selRadio1 = (paramRadios1.find(r => r.checked) || { value: 'upper' }).value;
      const selRadio2 = (paramRadios2.find(r => r.checked) || { value: 'upper' }).value;
      setOnly(1, selRadio1);
      setOnly(2, selRadio2);

      // On Year change, recreate sources for that panel and reapply selection and opacity
      if (yearSel1) {
        yearSel1.addEventListener('change', () => {
          const y = yearSel1.value;
          const op = opacity1El ? parseFloat(opacity1El.value) : 1.0;
          params.forEach(p => upsertParam(1, p, y, op));
          const sr = (paramRadios1.find(r => r.checked) || { value: 'upper' }).value;
          setOnly(1, sr);
        });
      }
      if (yearSel2) {
        yearSel2.addEventListener('change', () => {
          const y = yearSel2.value;
          const op = opacity2El ? parseFloat(opacity2El.value) : 0.0;
          params.forEach(p => upsertParam(2, p, y, op));
          const sr = (paramRadios2.find(r => r.checked) || { value: 'upper' }).value;
          setOnly(2, sr);
        });
      }

      // Opacity sliders wiring: update raster-opacity for all layers of that panel
      function setOpacity(panel, value) {
        params.forEach(p => {
          const id = lyrId(panel, p);
          if (map.getLayer(id)) map.setPaintProperty(id, 'raster-opacity', value);
        });
      }
      const op1Val = document.getElementById('mb-opacity-1-val');
      const op2Val = document.getElementById('mb-opacity-2-val');
      if (opacity1El) {
        opacity1El.addEventListener('input', () => {
          const v = parseFloat(opacity1El.value);
          if (op1Val) op1Val.textContent = v.toFixed(2);
          setOpacity(1, v);
        });
      }
      if (opacity2El) {
        opacity2El.addEventListener('input', () => {
          const v = parseFloat(opacity2El.value);
          if (op2Val) op2Val.textContent = v.toFixed(2);
          setOpacity(2, v);
        });
      }

      // Global map error logging for easier debugging
      map.on('error', (e) => {
        console.error('[Mapbox error]', e && e.error ? e.error : e);
      });

      // Add empty GeoJSON source/layer for click marker (above WMS, below labels if possible)
      if (!map.getSource('click-point')) {
        map.addSource('click-point', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });
      }
      if (!map.getLayer('click-point-layer')) {
        map.addLayer({
          id: 'click-point-layer',
          type: 'circle',
          source: 'click-point',
          paint: {
            'circle-radius': 6,
            'circle-color': '#e74c3c',
            'circle-stroke-color': '#ffffff',
            'circle-stroke-width': 1.5
          }
        }, beforeId);
      }

      // Resize nudges
      setTimeout(() => map.resize(), 200);
      requestAnimationFrame(() => map.resize());
    });
  }

  function maybeInitMbGlobeOnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#mb-globe')) {
      initMbGlobe();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMbGlobeOnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMbGlobeOnCurrentSlide);
    } else {
      initMbGlobe();
    }
  });
</script>


## Interactive map - HM forecast {.scrollable}

<div style="font-size:0.5em">

Here you can fully explore the HM forecasts for any region. Switch between years and lower, median, or upper forecasts to explore data. Data from 1990-2020 is observed and only available for the median (observed) values. From 2025 to 2040, values are forecasted and available at lower (2.5%), middle (median), and upper (97.5%) percentiles. You can click any point on the map to see the values for that location.

</div>

```{=html}
<link href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css" rel="stylesheet" />
<style>
  /* MapLibre panel styling for a cleaner look */
  .ml-controls { display:flex; flex-direction:column; gap:8px; margin-bottom:8px; font-size: 13px; }
  .ml-panel { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .ml-panel-title { font-weight:600; min-width:72px; font-size:13px; }
  .ml-panel label, .ml-panel span, .ml-panel select, .ml-panel small { font-size:13px; }
  .ml-chart-wrap { display:flex; justify-content:center; margin-top:10px; }
  .ml-chart-inner { width: 72vw; max-width: 980px; }
  #ml-edr { font-size:12px; color:#333; white-space:pre-wrap; text-align:center; margin-top:6px; }
  #ml-edr-chart { width:100%; height: 300px; max-height: 340px; }
  /* Tighten slider spacing */
  .ml-slider { display:flex; align-items:center; gap:8px; }
  .ml-spacer { flex:1; }
  /* Forecast legend */
  .ml-forecast-wrap { position: relative; }
  .ml-forecast-legend { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); max-width:260px; }
  .ml-forecast-legend .item { display:flex; align-items:center; gap:8px; margin:4px 0; }
  .ml-forecast-legend .swatch { width:14px; height:14px; border:1px solid rgba(0,0,0,0.4); border-radius:2px; }
</style>
<div class="ml-controls">
  <div class="ml-panel">
    <div class="ml-panel-title">Bottom layer</div>
    <label for="pm-year-1">Year:</label>
    <select id="pm-year-1">
      <option value="1990" selected>1990</option>
      <option value="1995">1995</option>
      <option value="2000">2000</option>
      <option value="2005">2005</option>
      <option value="2010">2010</option>
      <option value="2015">2015</option>
      <option value="2020">2020</option>
      <option value="2025">2025</option>
      <option value="2030">2030</option>
      <option value="2035">2035</option>
      <option value="2040">2040</option>
    </select>
    <label for="pm-param-1">Parameter:</label>
    <select id="pm-param-1">
      <option value="lower">Lower</option>
      <option value="middle" selected>Middle</option>
      <option value="upper">Upper</option>
    </select>
    <div class="ml-slider">
      <span>Opacity</span>
      <input type="range" id="pm-opacity-1" min="0" max="1" step="0.05" value="1">
      <span id="pm-opacity-1-val">1.00</span>
    </div>
  </div>
  <div class="ml-panel">
    <div class="ml-panel-title">Top layer</div>
    <label for="pm-year-2">Year:</label>
    <select id="pm-year-2">
      <option value="1990">1990</option>
      <option value="1995">1995</option>
      <option value="2000">2000</option>
      <option value="2005">2005</option>
      <option value="2010">2010</option>
      <option value="2015">2015</option>
      <option value="2020">2020</option>
      <option value="2025">2025</option>
      <option value="2030">2030</option>
      <option value="2035">2035</option>
      <option value="2040" selected>2040</option>
    </select>
    <label for="pm-param-2">Parameter:</label>
    <select id="pm-param-2">
      <option value="lower">Lower</option>
      <option value="middle" selected>Middle</option>
      <option value="upper">Upper</option>
    </select>
    <div class="ml-slider">
      <span>Opacity</span>
      <input type="range" id="pm-opacity-2" min="0" max="1" step="0.05" value="0">
      <span id="pm-opacity-2-val">0.00</span>
    </div>
    <div class="ml-spacer"></div>
  </div>
 </div>
<div class="ml-forecast-wrap">
  <div id="ml-pmtiles-globe" style="height: 420px; margin-top: 0.5rem;"></div>
  <div class="ml-forecast-legend" aria-label="HM legend">
    <div style="font-weight:600; margin-bottom:6px;">Overall Human Modification</div>
    <div class="item" style="align-items:center;">
      <div style="flex:1; height:14px; border:1px solid rgba(0,0,0,0.25); border-radius:2px; background: linear-gradient(to right, #30123b, #4145ab, #2c7bb6, #00a6ca, #00ccbc, #90eb9d, #f9d057, #f29e2e, #e76818, #d7191c);"></div>
    </div>
    <div style="display:flex; justify-content:space-between; font-size:11px;"><span>0</span><span>1</span></div>
  </div>
</div>
<div class="ml-chart-wrap">
  <div class="ml-chart-inner">
    <div id="ml-edr">Click on the map to fetch HM EDR time series…</div>
    <canvas id="ml-edr-chart"></canvas>
  </div>
</div>
```

<script src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3/dist/pmtiles.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
<script>
  let mlPmInited = false;
  let mlEdrChart = null;
  function initMlPmGlobe() {
    if (mlPmInited) return;
    mlPmInited = true;

    if (!window.maplibregl) {
      console.error('MapLibre GL not loaded');
      return;
    }

    // Minimal blank style; we'll add Esri + PMTiles sources/layers explicitly
    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map = new maplibregl.Map({
      container: 'ml-pmtiles-globe',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 1.8,
      attributionControl: true
    });

    map.on('style.load', () => {
      // MapLibre GL JS 5.x globe projection API
      try { map.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri World Imagery basemap (XYZ)
      const esriSrcId = 'esri-world';
      const esriLayerId = 'esri-world';
      if (!map.getSource(esriSrcId)) {
        map.addSource(esriSrcId, {
          type: 'raster',
          tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
          tileSize: 256,
          attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        });
      }
      if (!map.getLayer(esriLayerId)) {
        map.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });
      }

      // XYZ tiles URL template
      const buildXyzUrl = (param, year) => {
        return `https://compute.earthmover.io/v1/services/tiles/the-nature-conservancy/hm-multitemp/main/hm/tiles/WebMercatorQuad/{z}/{y}/{x}?variables=${param}&date=${year}-01-01T00:00:00&colorscalerange=0,1&style=raster/turbo&width=512&height=512`;
      };

      // Layer management for two panels
      const LAYER_IDS = { 1: 'xyz-layer-1', 2: 'xyz-layer-2' };
      const SOURCE_IDS = { 1: 'xyz-source-1', 2: 'xyz-source-2' };

      // Always keep panel 1 (Bottom layer) below panel 2 (Top layer)
      function enforceOrder() {
        try {
          if (map.getLayer(LAYER_IDS[1])) map.moveLayer(LAYER_IDS[1]); // send to top temporarily
          if (map.getLayer(LAYER_IDS[2])) map.moveLayer(LAYER_IDS[2]); // ensure layer 2 ends up on top
        } catch (e) {
          console.warn('Layer ordering warning:', e);
        }
      }

      // Function to update layer source with new year/param
      const updateLayer = (panel, param, year, opacity) => {
        const layerId = LAYER_IDS[panel];
        const sourceId = SOURCE_IDS[panel];
        const url = buildXyzUrl(param, year);
        
        // Remove existing layer and source
        if (map.getLayer(layerId)) map.removeLayer(layerId);
        if (map.getSource(sourceId)) map.removeSource(sourceId);
        
        // Add new source and layer
        map.addSource(sourceId, {
          type: 'raster',
          tiles: [url],
          tileSize: 256
        });
        map.addLayer({
          id: layerId,
          type: 'raster',
          source: sourceId,
          paint: { 'raster-opacity': opacity }
        });
        // Re-apply canonical order after any update
        enforceOrder();
      };

      // Helper to apply opacity to existing layer
      function applyOpacity(panel, value) {
        const layerId = LAYER_IDS[panel];
        if (map.getLayer(layerId)) {
          try { map.setPaintProperty(layerId, 'raster-opacity', value); } catch (e) {}
        }
      }

      // Wire UI controls
      const year1 = document.getElementById('pm-year-1');
      const param1 = document.getElementById('pm-param-1');
      const year2 = document.getElementById('pm-year-2');
      const param2 = document.getElementById('pm-param-2');
      const op1 = document.getElementById('pm-opacity-1');
      const op2 = document.getElementById('pm-opacity-2');
      const op1Val = document.getElementById('pm-opacity-1-val');
      const op2Val = document.getElementById('pm-opacity-2-val');

      // Initial state
      const initYear1 = year1 ? year1.value : '1990';
      const initParam1 = param1 ? param1.value : 'middle';
      const initYear2 = year2 ? year2.value : '2040';
      const initParam2 = param2 ? param2.value : 'middle';
      const initOp1 = op1 ? parseFloat(op1.value) : 1.0;
      const initOp2 = op2 ? parseFloat(op2.value) : 0.0;
      
      updateLayer(1, initParam1, initYear1, initOp1);
      updateLayer(2, initParam2, initYear2, initOp2);
      if (op1Val) op1Val.textContent = initOp1.toFixed(2);
      if (op2Val) op2Val.textContent = initOp2.toFixed(2);
      // Ensure initial z-order is correct (Bottom below Top)
      enforceOrder();

      // Event listeners for layer 1
      const updateLayer1 = () => {
        const y = year1 ? year1.value : '1990';
        const p = param1 ? param1.value : 'middle';
        const o = op1 ? parseFloat(op1.value) : 1.0;
        updateLayer(1, p, y, o);
      };
      if (year1) year1.addEventListener('change', updateLayer1);
      if (param1) param1.addEventListener('change', updateLayer1);
      
      // Event listeners for layer 2
      const updateLayer2 = () => {
        const y = year2 ? year2.value : '2040';
        const p = param2 ? param2.value : 'middle';
        const o = op2 ? parseFloat(op2.value) : 0.0;
        updateLayer(2, p, y, o);
      };
      if (year2) year2.addEventListener('change', updateLayer2);
      if (param2) param2.addEventListener('change', updateLayer2);
      
      // Opacity controls
      if (op1) op1.addEventListener('input', () => { const v = parseFloat(op1.value); if (op1Val) op1Val.textContent = v.toFixed(2); applyOpacity(1, v); });
      if (op2) op2.addEventListener('input', () => { const v = parseFloat(op2.value); if (op2Val) op2Val.textContent = v.toFixed(2); applyOpacity(2, v); });

      // EDR click handler (replicates Mapbox slide behavior)
      const edrEl = document.getElementById('ml-edr');
      const chartEl = document.getElementById('ml-edr-chart');
      const CUTOVER_MS = Date.UTC(2020, 0, 1);

      function ensureSpinnerCss() {
        if (!document.getElementById('edr-spinner-style')) {
          const style = document.createElement('style');
          style.id = 'edr-spinner-style';
          style.textContent = `
            .edr-spinner { display:inline-block; width:14px; height:14px; border:2px solid rgba(0,0,0,0.15); border-top-color: rgba(0,0,0,0.6); border-radius:50%; animation: edr-spin 0.8s linear infinite; vertical-align:middle; }
            @keyframes edr-spin { to { transform: rotate(360deg); } }
          `;
          document.head.appendChild(style);
        }
      }

      async function fetchEdrSeries(lng, lat) {
        ensureSpinnerCss();
        if (edrEl) edrEl.innerHTML = '<span class="edr-spinner" aria-label="Loading" title="Loading"></span>';
        const coordsWKT = `POINT(${lng} ${lat})`;
        const makeUrl = (param) => `https://compute.earthmover.io/v1/services/edr/the-nature-conservancy/hm-multitemp/main/hm/edr/position?coords=${encodeURIComponent(coordsWKT)}&parameter-name=${param}`;
        const paramsList = ['upper','middle','lower'];
        const results = await Promise.all(paramsList.map(p => fetch(makeUrl(p)).then(r => r.json()).then(data => ({ p, data })).catch(error => ({ p, error }))));

        const START_MS = Date.parse('1990-01-01');
        const CUTOVER_MS = Date.parse('2020-01-01');
        const END_MS = Date.parse('2040-01-01');

        const series = { upper: [], middle: [], lower: [] };
        results.forEach(({ p, data, error }) => {
          if (error || !data || !series[p]) return;
          const dates = data?.domain?.axes?.date?.values || data?.domain?.axes?.t?.values || [];
          const vals = data?.ranges?.[p]?.values || [];
          if (Array.isArray(dates) && Array.isArray(vals) && dates.length && vals.length) {
            series[p] = dates
              .map((d, i) => ({ x: Date.parse(d), y: vals[i] }))
              .filter(pt => Number.isFinite(pt.x) && Number.isFinite(pt.y) && pt.x >= START_MS && pt.x <= END_MS)
              .sort((a,b) => a.x - b.x);
          }
        });

        // Build confidence band arrays from CUTOVER forward, bridged at CUTOVER using middle value
        const lastObservedMiddle = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
        const cutY = lastObservedMiddle ? lastObservedMiddle.y : null;
        let lowerBand = series.lower.filter(pt => pt.x >= CUTOVER_MS);
        let upperBand = series.upper.filter(pt => pt.x >= CUTOVER_MS);
        if (cutY !== null) {
          lowerBand = [{ x: CUTOVER_MS, y: cutY }, ...lowerBand];
          upperBand = [{ x: CUTOVER_MS, y: cutY }, ...upperBand];
        }

        // Split middle into observed/predicted with bridging point
        let observed = series.middle.map(pt => (pt.x <= CUTOVER_MS ? pt : { x: pt.x, y: null }));
        let predicted = series.middle.filter(pt => pt.x >= CUTOVER_MS);
        const prevPt = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
        const hasCutObserved = observed.some(pt => pt.x === CUTOVER_MS && pt.y !== null);
        const hasCutPred = predicted.some(pt => pt.x === CUTOVER_MS);
        if (prevPt) {
          const bridge = { x: CUTOVER_MS, y: prevPt.y };
          if (!hasCutObserved) observed = [...observed.filter(pt => pt.x < CUTOVER_MS), bridge, ...observed.filter(pt => pt.x > CUTOVER_MS)];
          if (!hasCutPred) predicted = [bridge, ...predicted];
        }
        observed.sort((a,b) => a.x - b.x);
        predicted.sort((a,b) => a.x - b.x);

        return { series, lowerBand, upperBand, observed, predicted, START_MS, END_MS };
      }

      function renderChart(res) {
        const ctx = chartEl?.getContext('2d');
        if (!ctx) return;
        try { if (mlEdrChart) { mlEdrChart.destroy(); } } catch(_) {}
        mlEdrChart = null;

        const colors = { upper: '#e41a1c', middle: '#377eb8', lower: '#4daf4a' };
        const lowerDs = { label: '', data: res.lowerBand, borderColor: 'transparent', backgroundColor: 'transparent', pointRadius: 0, borderWidth: 0, tension: 0.2, fill: false };
        const bandDs = { label: '95% confidence', data: res.upperBand, borderColor: 'transparent', backgroundColor: (colors.upper || '#e41a1c') + '33', pointRadius: 0, borderWidth: 0, tension: 0.2, fill: '-1' };
        const observedDs = { label: 'observed', data: res.observed, borderColor: colors.middle, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, borderDash: [], tension: 0.2, fill: false };
        const predictedDs = { label: 'predicted', data: res.predicted, borderColor: colors.middle, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, borderDash: [6,4], tension: 0.2, fill: false };

        mlEdrChart = new Chart(ctx, {
          type: 'line',
          data: { datasets: [lowerDs, bandDs, observedDs, predictedDs] },
          options: {
            maintainAspectRatio: false,
            parsing: false,
            spanGaps: true,
            scales: {
              x: { type: 'linear', min: res.START_MS, max: res.END_MS, ticks: { maxTicksLimit: 6, callback: (v) => { try { return new Date(v).toISOString().slice(0, 4); } catch { return v; } } } },
              y: { title: { display: true, text: 'Human Modification Index' } }
            },
            plugins: {
              legend: { display: true, labels: { filter: (item) => !!item.text } },
              tooltip: { callbacks: { label: (ctx) => { const label = ctx.dataset && typeof ctx.dataset.label === 'string' ? ctx.dataset.label : ''; if (!label || label.startsWith('_')) return null; const x = ctx.parsed.x; const y = ctx.parsed.y; const ts = new Date(x).toISOString().slice(0,19).replace('T',' '); return ` ${label}: ${y}  •  ${ts}`; } } }
            }
          }
        });
      }

      // Click marker
      let clickMarker = null;
      map.on('click', async (e) => {
        const { lng, lat } = e.lngLat;
        try { if (clickMarker) { clickMarker.remove(); } } catch(_) {}
        clickMarker = new maplibregl.Marker({ color: '#e11d48', scale: 0.9 })
          .setLngLat([lng, lat])
          .addTo(map);
        try {
          const result = await fetchEdrSeries(lng, lat);
          if (edrEl) edrEl.textContent = `EDR at (${lng.toFixed(4)}, ${lat.toFixed(4)})`;
          renderChart(result);
        } catch (err) {
          if (edrEl) edrEl.textContent = 'EDR error';
          console.error('EDR error:', err);
        }
      });

      // Resize passes after layout transition
      setTimeout(() => map.resize(), 200);
      requestAnimationFrame(() => map.resize());
    });
  }

  function maybeInitMlPmOnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe')) {
      initMlPmGlobe();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPmOnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPmOnCurrentSlide);
    } else {
      initMlPmGlobe();
    }
  });
</script>

---

## Interactive map - Intact lands

<div style="font-size:0.5em">

We can define a threshold HM value above which we may believe lands can no longer be assumed to be natural. Here we choose 0.1 HM as the threshold, and map the extent of intact lands in 2040 and intact lands lost between 2020 and 2040 (going above 0.1) based on HM modeled at different confidence levels. Orange indicates that loss of natural lands between 2020 and 2040 is the most likely outcome, Pink indicates that loss is possible under the worst-case (upper 95%) scenario, and purple indicates that land remains intact in 2040 even in the worst-case scenario.

</div>

```{=html}
<style>
  /* Scoped styles for 2nd MapLibre legend (Inferno categories) */
  .ml2-map-wrap { position: relative; }
  .ml2-legend { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); }
  .ml2-legend-item { display:flex; align-items:center; gap:8px; margin:4px 0; }
  .ml2-swatch { width:14px; height:14px; border:1px solid rgba(0,0,0,0.4); border-radius:2px; }
  .ml2-ctrl { margin-top:6px; font-size:12px; display:flex; align-items:center; gap:8px; }
  .ml2-ctrl input[type="range"] { width:120px; }
  @media (max-width: 720px) { .ml2-legend { font-size:12px; } }
</style>
<div class="ml2-map-wrap">
  <div id="ml-pmtiles-globe-2" style="height: 460px; margin-top: 0.5rem;"></div>
  <div class="ml2-legend" aria-label="Map legend">
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#3b0f70;"></span><span>intact</span></div>
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#9c179e;"></span><span>converted 97.5%</span></div>
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#f98e09;"></span><span>converted 50%</span></div>
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#fcffa4;"></span><span>converted 2.5%</span></div>
    <div class="ml2-ctrl">
      <span>Opacity</span>
      <input id="ml2-opacity" type="range" min="0" max="1" step="0.05" value="0.95" />
      <span id="ml2-opacity-val">0.95</span>
    </div>
  </div>
</div>
```

<script>
  let mlPm2Inited = false;
  function initMlPmGlobe2() {
    if (mlPm2Inited) return;
    mlPm2Inited = true;
    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }
    // Register pmtiles protocol (ignore if already registered)
    try {
      const protocol2 = new pmtiles.Protocol();
      if (typeof maplibregl.addProtocol === 'function') {
        try { maplibregl.addProtocol('pmtiles', protocol2.tile); } catch (_) {}
      }
    } catch (_) {}

    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map2 = new maplibregl.Map({
      container: 'ml-pmtiles-globe-2',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 2,
      attributionControl: true
    });

    map2.on('style.load', () => {
      try { map2.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri basemap
      const esriSrcId = 'esri-world-2';
      const esriLayerId = 'esri-world-2';
      map2.addSource(esriSrcId, {
        type: 'raster',
        tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        tileSize: 256,
        attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });
      map2.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });

      // PMTiles: show 'new' only
      const pmtilesNew = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/land_z0-7.pmtiles';
      const srcNewId = 'pmtiles-new-2';
      const layerNewId = 'pmtiles-new-2';
      map2.addSource(srcNewId, { type: 'raster', tiles: [`pmtiles://${pmtilesNew}/{z}/{x}/{y}`], tileSize: 512 });
      map2.addLayer({ id: layerNewId, type: 'raster', source: srcNewId, paint: { 'raster-opacity': 0.95 } });

      // Opacity slider wiring
      const op = document.getElementById('ml2-opacity');
      const opVal = document.getElementById('ml2-opacity-val');
      if (op) {
        const setOp = (v) => { try { map2.setPaintProperty(layerNewId, 'raster-opacity', v); if (opVal) opVal.textContent = (+v).toFixed(2); } catch(e) {} };
        setOp(parseFloat(op.value || '0.95'));
        op.addEventListener('input', () => setOp(parseFloat(op.value)));
      }

      // Resize nudges
      setTimeout(() => map2.resize(), 200);
      requestAnimationFrame(() => map2.resize());
    });
  }

  function maybeInitMlPm2OnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe-2')) {
      initMlPmGlobe2();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPm2OnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPm2OnCurrentSlide);
    } else {
      initMlPmGlobe2();
    }
  });
</script>

---

## Interactive map - HM increase

<div style="font-size:0.5em">

HM increase is defined as the difference between the median predicted 2040 HM value and the observed 2020 HM value. 

</div>

```{=html}
<style>
  /* Simple layout without legend */
  .ml3-wrap { position: relative; }
  .ml3-ctrl { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); display:flex; align-items:center; gap:8px; }
  .ml3-ctrl input[type="range"] { width:120px; }
  @media (max-width: 720px) { .ml3-ctrl { font-size:12px; } }
  /* Legend (coolwarm) */
  .ml3-legend { position:absolute; right:10px; top:60px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); width:180px; }
  .ml3-legend .title { font-weight:600; margin-bottom:6px; }
  .ml3-legend .bar { height:12px; border:1px solid rgba(0,0,0,0.25); background: linear-gradient(to right, #3b4cc0, #d4dbe6 50%, #b40426); border-radius:2px; }
  .ml3-legend .ticks { display:flex; justify-content:space-between; font-size:11px; margin-top:4px; }
</style>
<div class="ml3-wrap">
  <div id="ml-pmtiles-globe-3" style="height: 460px; margin-top: 0.5rem;"></div>
  <div class="ml3-ctrl" aria-label="Opacity control">
    <span>Opacity</span>
    <input id="ml3-opacity" type="range" min="0" max="1" step="0.05" value="0.95" />
    <span id="ml3-opacity-val">0.95</span>
  </div>
  <div class="ml3-legend" aria-label="Legend">
    <div class="title">HM increase (2020–2040)</div>
    <div class="bar"></div>
    <div class="ticks"><span>-0.1</span><span>0</span><span>0.1</span></div>
  </div>
</div>
```

<script>
  let mlPm3Inited = false;
  function initMlPmGlobe3() {
    if (mlPm3Inited) return;
    mlPm3Inited = true;
    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }
    // Register pmtiles protocol (ignore if already registered)
    try {
      const protocol3 = new pmtiles.Protocol();
      if (typeof maplibregl.addProtocol === 'function') {
        try { maplibregl.addProtocol('pmtiles', protocol3.tile); } catch (_) {}
      }
    } catch (_) {}

    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map3 = new maplibregl.Map({
      container: 'ml-pmtiles-globe-3',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 2,
      attributionControl: true
    });

    map3.on('style.load', () => {
      try { map3.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri basemap
      const esriSrcId = 'esri-world-3';
      const esriLayerId = 'esri-world-3';
      map3.addSource(esriSrcId, {
        type: 'raster',
        tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        tileSize: 256,
        attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });
      map3.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });

      // PMTiles: HM increase 2020-2040
      const pmtilesUrl = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/diff2040.pmtiles';
      const srcId = 'pmtiles-low2040-3';
      const layerId = 'pmtiles-low2040-3';
      map3.addSource(srcId, { type: 'raster', tiles: [`pmtiles://${pmtilesUrl}/{z}/{x}/{y}`], tileSize: 512 });
      map3.addLayer({ id: layerId, type: 'raster', source: srcId, paint: { 'raster-opacity': 0.95 } });

      // Opacity slider wiring
      const op = document.getElementById('ml3-opacity');
      const opVal = document.getElementById('ml3-opacity-val');
      if (op) {
        const setOp = (v) => { try { map3.setPaintProperty(layerId, 'raster-opacity', v); if (opVal) opVal.textContent = (+v).toFixed(2); } catch(e) {} };
        setOp(parseFloat(op.value || '0.95'));
        op.addEventListener('input', () => setOp(parseFloat(op.value)));
      }

      // Resize nudges
      setTimeout(() => map3.resize(), 200);
      requestAnimationFrame(() => map3.resize());
    });
  }

  function maybeInitMlPm3OnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe-3')) {
      initMlPmGlobe3();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPm3OnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPm3OnCurrentSlide);
    } else {
      initMlPmGlobe3();
    }
  });
</script>

---

## Interactive map - Uncertainty

<div style="font-size:0.5em">

HM uncertainty is defined as the difference between the upper (97.5%) predicted 2040 HM value and the lower (2.5%) predicted 2040 HM value.

</div>

```{=html}
<style>
  /* Simple layout without legend (duplicate of HM increase) */
  .ml4-wrap { position: relative; }
  .ml4-ctrl { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); display:flex; align-items:center; gap:8px; }
  .ml4-ctrl input[type="range"] { width:120px; }
  @media (max-width: 720px) { .ml4-ctrl { font-size:12px; } }
  /* Legend (inferno) */
  .ml4-legend { position:absolute; right:10px; top:60px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); width:180px; }
  .ml4-legend .title { font-weight:600; margin-bottom:6px; }
  .ml4-legend .bar { height:12px; border:1px solid rgba(0,0,0,0.25); background: linear-gradient(to right, #000004, #1f0c48, #550f6d, #88226a, #b63655, #e35933, #fca50a, #fcffa4); border-radius:2px; }
  .ml4-legend .ticks { display:flex; justify-content:space-between; font-size:11px; margin-top:4px; }
</style>
<div class="ml4-wrap">
  <div id="ml-pmtiles-globe-4" style="height: 460px; margin-top: 0.5rem;"></div>
  <div class="ml4-ctrl" aria-label="Opacity control">
    <span>Opacity</span>
    <input id="ml4-opacity" type="range" min="0" max="1" step="0.05" value="0.95" />
    <span id="ml4-opacity-val">0.95</span>
  </div>
  <div class="ml4-legend" aria-label="Legend">
    <div class="title">Uncertainty (σ)</div>
    <div class="bar"></div>
    <div class="ticks"><span>0.0</span><span>0.2</span><span>0.4</span></div>
  </div>
</div>
```

<script>
  let mlPm4Inited = false;
  function initMlPmGlobe4() {
    if (mlPm4Inited) return;
    mlPm4Inited = true;
    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }
    // Register pmtiles protocol (ignore if already registered)
    try {
      const protocol4 = new pmtiles.Protocol();
      if (typeof maplibregl.addProtocol === 'function') {
        try { maplibregl.addProtocol('pmtiles', protocol4.tile); } catch (_) {}
      }
    } catch (_) {}

    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map4 = new maplibregl.Map({
      container: 'ml-pmtiles-globe-4',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 2,
      attributionControl: true
    });

    map4.on('style.load', () => {
      try { map4.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri basemap
      const esriSrcId = 'esri-world-4';
      const esriLayerId = 'esri-world-4';
      map4.addSource(esriSrcId, {
        type: 'raster',
        tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        tileSize: 256,
        attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });
      map4.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });

      // PMTiles: duplicate of HM increase slide
      const pmtilesUrl = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/duplo_katie.pmtiles';
      const srcId = 'pmtiles-low2040-4';
      const layerId = 'pmtiles-low2040-4';
      map4.addSource(srcId, { type: 'raster', tiles: [`pmtiles://${pmtilesUrl}/{z}/{x}/{y}`], tileSize: 512 });
      map4.addLayer({ id: layerId, type: 'raster', source: srcId, paint: { 'raster-opacity': 0.95 } });

      // Opacity slider wiring
      const op = document.getElementById('ml4-opacity');
      const opVal = document.getElementById('ml4-opacity-val');
      if (op) {
        const setOp = (v) => { try { map4.setPaintProperty(layerId, 'raster-opacity', v); if (opVal) opVal.textContent = (+v).toFixed(2); } catch(e) {} };
        setOp(parseFloat(op.value || '0.95'));
        op.addEventListener('input', () => setOp(parseFloat(op.value)));
      }

      // Resize nudges
      setTimeout(() => map4.resize(), 200);
      requestAnimationFrame(() => map4.resize());
    });
  }

  function maybeInitMlPm4OnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe-4')) {
      initMlPmGlobe4();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPm4OnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPm4OnCurrentSlide);
    } else {
      initMlPmGlobe4();
    }
  });
</script>

---

## Downloads
<br><br><br>
Box folder for TNC staff with data and symbolology <br>
[here](https://tnc.box.com/s/b488ihv2pa3j81qrm8qgsct1e14ivyfp)

## Questions
<div style="font-size:0.5em">
Thank you for taking the time to review this analysis and dataset. Below are some example questions we would like you to consider. You are also welcome to share any other thoughts or comments. We would be extremely grateful for your feedback. This information will be used to update the analysis and improve the model.
<br><br>

- For regions familiar to you, in which areas do the predictions match your expectations? In which areas do they not?

- Are there obvious errors or unreasonable patterns?

- Are there regions where the uncertainty is too high or too low? 

- In places where the model is not performing well, can you think of additional information that might help improve the predictions?

- How would you use this information to make decisions relevant to your strategy or business unit?

- Are you aware of any analyses or datasets for which this information could be used as an input?

- Are there decisions or analyses for which existing land conversion forecasts are not relevant but this information is?

- What improvements or additions to this analysis would you like to see?

<br><br>

</div>

<div style="font-size:0.6em">
<b>Send your feedback to:</b>
<br>
[glenn.moncrieff@tnc.org](mailto:glenn.moncrieff@tnc.org)
</div>


