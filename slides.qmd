---
title: "Nature in 2040"
subtitle: "Forecasting Human Modification of Global Lands from 2020 to 2040"
author: "Glenn Moncrieff, Maria Voigt, Christina Kennedy - Global Science TNC <br> Jim Oakleaf, Joe Kiesecker - Global Protect TNC"
date: "2025-08-19"
format:
  revealjs:
    theme: simple
    slide-number: true
    # ↓↓↓ add these two lines
    scrollable: true     # allow the page itself to scroll
    center: false        # start content at the top, not vertically centred
    include-in-header: header.html
output-file: index.html
---

## Global Human Modification

<div style="font-size:0.5em">
 The Global Human Modification (HM) index [Theobald et al 2024](https://www.nature.com/articles/s41597-025-04892-2) measures the impact of human activites on nature by quantifying the distribution and intesnity of 14 threats globally. It ranges from 0 (no human impact) to 1 (maximum human impact). These 14 threats are summarized into a single cumulative index representing the overall impact of human activities on nature. A time series of this index is available from 1990 to 2020 every 5 years at 300m resolution for both the individual threats and the cumulative index. 

[![](/images/hm1.png)](https://www.nature.com/articles/s41597-025-04892-2)
</div>

## Forecasting HM
<div style="font-size:0.5em">
Forecasts of human impacts help us anticipate where and when pressures on ecosystems are likely to intensify, allowing proactive rather than reactive action. By linking projected changes to planning, they guide decisions on where to prioritize protection, restoration, or policy interventions for the greatest long-term benefit.

![Impact](/images/impact1.png) <br>
But forecasting human impacts is not easy. There is a trade-off between the level of detail in the forecast and the uncertainty/accuracy of the forecast.
<br>
e.g.<br><br>


**High detail - actionable but hard to predict**<br>
Will a specifc 300m pixel be converted to housing between 2095 and 2100?<br>
_How much will it rain in my neighbourhood park on the 3rd Monday in July in 2028_<br><br>

**Medium detail - informataive and somewhat predictable**<br>
Overall change in human pressue at 1km resolution between 2020 and 2040<br>
_Likelihood the maximum monthly temp in July 2050 in Denver will exceed 90F /32C in 2050_<br><br>

**Low detail -less useful but more predictable**<br>
Overall pressue at Country scale in 2030<br>
_The global average temperature in 2030_<br><br>
</div>

## Our approach
<div style="font-size:0.5em">
We use a multi-horizon forecast approach to forecast human modification at 1km resolution for the period 2020-2040. We use a range of covariates to predict human modification, including population, economic development, and infrastructure development. The multi-horizon approach allows us to forecast human modification at different time horizons, from short-term (5 year) to long-term (20 year). </div>
<br>
![](/images/hm_model2.gif){style="width:300%"}

## Model covariates
<div style="font-size:0.5em">

- **Topography**  
  Elevation, Slope, Aspect, Topographic Position Index

- **Climate**  
  Temperature, Precipitation

- **Population**  
  Population density at 1km resolution from 1990 to 2040

- **NPP**  
  Potential under historical climate

- **GDP**  
  GDP at 1km resolution from 1990 to 2040

- **Protected areas**  
  Encoded at 0/1

- **Development Pressure**  
  Development Suitabilty Index ranks development suitability scores from 0 (lowest) to 1 (highest) based on the average score across all development potential indices (DPIs) multiplied by the maximum score 
  ![](/images/dsi.png) [Oakleaf et al 2024](https://www.nature.com/articles/s41597-024-03639-9) 

- **Location**  
  Encodes the influence of location (unaccounted for by covarites) on human modification change. 
    ![](/images/location.png) [Russwurm et al 2024](https://arxiv.org/abs/2310.06743) 

- **Neighborhood**  
  Average past HM and past HM change with a 6km and  120km radius using uber h3 spatial index
 ![](/images/h3.png)
</div>

## Model performance
<div style="font-size:0.5em">
Comparing the fitted models against baseline assumptions - In the absence of a model we might assume either the status quo (zero change) or a linear trend. How does our model compare to these baselines over different horizons?
 ![](/images/horizon.png)

 Assuming that 5 years time will be the same as now is a hard baseline to beat, but as we go further into the future the model becomes better. It is never a great idea to assume that the change we last observed will continue in the future. 

 <br><br>
 How well can we predict HM in 20 years time?  <br><br> ![](/images/abs_err.png)  <br><br>Very well!  <br><br>
 But remember, just assuming it wont change works pretty well, so predicting the absolute value is not that hard
 <br><br>
  How well can we predict how much HM will change in 20 years time?  <br><br> ![](/images/diff_err.png)  <br><br> It is hard, but we get the overall direction and magnitude right
 <br><br>
</div>

## Change through time: Observed vs predicted
<div style="font-size:0.5em">
What do individual pixels look like? We see some in which it is quite certain they will remain intact and not change, some we suspect might become less intact, and some where we are very uncertain. Including uncertainty captures the range of possible outcomes and helps us understand the risk of different scenarios.

 <br><br>
![](/images/timeseries.png)
  <br><br>

 We might not always get the mean prediction correct - this is a very hard problem to predict. But we can get well calibrated ranges so that we are 95% certain the true outcome will lie within these bounds. 
</div>

## Map of predicted change
<div style="font-size:0.7em">
Timeseries of observed change in overall HM 1990-2020 and predicted change 2020-2050 - Yucatan Peninsula
![](/images/1_fullts.gif)

Difference between upper and lower bounds of predicted change 2030 - Yucatan Peninsula
![](/images/2_uncer.gif)

</div>

## Model insights
<div style="font-size:0.7em">
What is driving the change? We can poke the model to find out which covariates are most important overall and for individual pixels. 

<br><br>
![](/images/importance.png)<br><br>
![](/images/variable_importance.png)
<br><br>

more work to come here
</div>

## Globe (Mapbox + WMS) {data-visibility="hidden"}

```{=html}
<link href="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.css" rel="stylesheet" />
<div id="mb-globe-wrap" style="position:relative;">
  <div id="mb-globe" style="height: 500px; margin-top: 1rem;"></div>
  <!-- Layer toggle controls: Panel 1 -->
  <div id="mb-layer-controls-1" style="position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; font-size:14px; box-shadow:0 1px 4px rgba(0,0,0,0.2); min-width: 220px;">
    <div style="font-weight:700; margin-bottom:6px;">Human Modification Index</div>
    <div style="font-weight:600; margin-bottom:4px;">Year</div>
    <div style="margin-bottom:6px;">
      <select id="mb-year-1" style="width:100%;">
        <option value="1990-01-01">1990</option>
        <option value="1995-01-01">1995</option>
        <option value="2000-01-01">2000</option>
        <option value="2005-01-01">2005</option>
        <option value="2010-01-01">2010</option>
        <option value="2015-01-01">2015</option>
        <option value="2020-01-01">2020</option>
        <option value="2025-01-01">2025</option>
        <option value="2030-01-01">2030</option>
        <option value="2035-01-01">2035</option>
        <option value="2040-01-01">2040</option>
      </select>
    </div>
    <div style="border-top: 1px solid #ddd; margin:6px 0;"></div>
    <div style="font-weight:600; margin-bottom:4px;">Quantile</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-upper" value="upper" checked> <span>upper</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-middle" value="middle"> <span>middle</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-lower" value="lower"> <span>lower</span></label>
    </div>
    <div style="margin-top:6px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <span>Opacity</span>
        <input type="range" id="mb-opacity-1" min="0" max="1" step="0.05" value="1">
        <span id="mb-opacity-1-val">1.00</span>
      </label>
    </div>
  </div>
  <!-- Layer toggle controls: Panel 2 -->
  <div id="mb-layer-controls-2" style="position:absolute; right:10px; top:170px; z-index:999; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; font-size:14px; box-shadow:0 1px 4px rgba(0,0,0,0.2); min-width: 220px;">
    <div style="font-weight:700; margin-bottom:6px;">Human Modification Index</div>
    <div style="font-weight:600; margin-bottom:4px;">Year</div>
    <div style="margin-bottom:6px;">
      <select id="mb-year-2" style="width:100%;">
        <option value="1990-01-01">1990</option>
        <option value="1995-01-01">1995</option>
        <option value="2000-01-01">2000</option>
        <option value="2005-01-01">2005</option>
        <option value="2010-01-01">2010</option>
        <option value="2015-01-01">2015</option>
        <option value="2020-01-01">2020</option>
        <option value="2025-01-01">2025</option>
        <option value="2030-01-01">2030</option>
        <option value="2035-01-01">2035</option>
        <option value="2040-01-01">2040</option>
      </select>
    </div>
    <div style="border-top: 1px solid #ddd; margin:6px 0;"></div>
    <div style="font-weight:600; margin-bottom:4px;">Quantile</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-upper" value="upper" checked> <span>upper</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-middle" value="middle"> <span>middle</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-lower" value="lower"> <span>lower</span></label>
    </div>
    <div style="margin-top:6px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <span>Opacity</span>
        <input type="range" id="mb-opacity-2" min="0" max="1" step="0.05" value="0">
        <span id="mb-opacity-2-val">0.00</span>
      </label>
    </div>
  </div>
  
  <!-- Click coords readout -->
  <div id="mb-coords" style="margin-top: 8px; font-size: 13px; color:#333;">
    Click on the globe to see lon/lat here.
  </div>
  <div id="mb-edr" style="margin-top: 6px; font-size: 12px; color:#333; white-space: pre-wrap;"></div>
  <!-- Air through time chart -->
  <div id="air-chart-wrap" style="height: 220px; margin-top: 8px; background: #fff; border: 1px solid #eee; border-radius: 4px; padding: 6px;">
    <canvas id="air-chart" height="200"></canvas>
  </div>
  
</div>
```

<link href="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.js"></script>
<!-- Chart.js + date adapter for time scale -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js"></script>
<script>
  let mbGlobeInited = false;
  // Chart instance holder
  let airChart = null;
  function initMbGlobe() {
    if (mbGlobeInited) return;
    mbGlobeInited = true;

    // Expect token set globally as window.MAPBOX_TOKEN; no hardcoded fallback
    if (window.MAPBOX_TOKEN) {
      mapboxgl.accessToken = window.MAPBOX_TOKEN;
    } else {
      console.warn('Mapbox token missing. Set MAPBOX_TOKEN env var before rendering the Mapbox globe slide.');
    }

    const map = new mapboxgl.Map({
      container: 'mb-globe',
      style: 'mapbox://styles/mapbox/satellite-streets-v12',
      zoom: 1,
      center: [-74.5447, 40.6892],
      attributionControl: true
    });

    // Show last-clicked lon/lat under the globe and drop/update a marker
    const coordEl = document.getElementById('mb-coords');
    function fmt(n) { return (Math.round(n * 10000) / 10000).toFixed(4); }
    if (coordEl) {
      map.on('click', (e) => {
        const { lng, lat } = e.lngLat;
        coordEl.textContent = `Lon: ${fmt(lng)}, Lat: ${fmt(lat)}`;
        // Update click-point GeoJSON source if present
        const src = map.getSource('click-point');
        if (src) {
          src.setData({
            type: 'FeatureCollection',
            features: [
              {
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [lng, lat] },
                properties: {}
              }
            ]
          });
        }

        // Fetch EDR for three quantiles and plot together
        const edrEl = document.getElementById('mb-edr');
        if (edrEl) {
          // Show a lightweight spinner while fetching
          if (!document.getElementById('edr-spinner-style')) {
            const style = document.createElement('style');
            style.id = 'edr-spinner-style';
            style.textContent = `
              .edr-spinner { display:inline-block; width:14px; height:14px; border:2px solid rgba(0,0,0,0.15); border-top-color: rgba(0,0,0,0.6); border-radius:50%; animation: edr-spin 0.8s linear infinite; vertical-align:middle; }
              @keyframes edr-spin { to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);
          }
          edrEl.innerHTML = '<span class="edr-spinner" aria-label="Loading" title="Loading"></span>';
          const coordsWKT = `POINT(${lng} ${lat})`;
          const makeUrl = (param) => `https://compute.earthmover.io/v1/services/edr/the-nature-conservancy/hm-multitemp/main/hm/edr/position?coords=${encodeURIComponent(coordsWKT)}&parameter-name=${param}`;
          const paramsList = ['upper','middle','lower'];
          Promise.all(paramsList.map(p => fetch(makeUrl(p)).then(r => r.json()).then(data => ({ p, data })).catch(err => ({ p, error: err }))))
            .then(results => {
              // Collect points per param within date window
              const colors = { upper: '#e41a1c', middle: '#377eb8', lower: '#4daf4a' };
              const series = { upper: [], middle: [], lower: [] };
              const START_MS = Date.parse('1990-01-01');
              const CUTOVER_MS = Date.parse('2020-01-01');
              const END_MS = Date.parse('2040-01-01');
              let firstText = '';
              results.forEach(({ p, data, error }) => {
                if (error || !data || !series[p]) return;
                const dates = data?.domain?.axes?.date?.values || data?.domain?.axes?.t?.values || [];
                const vals = data?.ranges?.[p]?.values || [];
                if (Array.isArray(dates) && Array.isArray(vals) && dates.length && vals.length) {
                  series[p] = dates
                    .map((d, i) => ({ x: Date.parse(d), y: vals[i] }))
                    .filter(pt => Number.isFinite(pt.x) && Number.isFinite(pt.y) && pt.x >= START_MS && pt.x <= END_MS);
                  if (!firstText) firstText = `Date: ${dates[0]}  •  ${p}: ${vals[0]}`;
                }
              });
              // Stop showing spinner regardless of whether data was found
              edrEl.innerHTML = '';

              // Build datasets: shaded 95% confidence (upper to lower), plus middle as observed/predicted
              // Make the confidence band converge to a single point at the last observed year (CUTOVER_MS)
              // using the middle series value at CUTOVER_MS, then expand from first forecast year (e.g., 2025).
              const lastObservedMiddle = [...series.middle]
                .filter(pt => pt.x <= CUTOVER_MS)
                .sort((a,b) => a.x - b.x)
                .slice(-1)[0];
              const cutY = lastObservedMiddle ? lastObservedMiddle.y : null;
              let lowerBand = series.lower.filter(pt => pt.x >= CUTOVER_MS);
              let upperBand = series.upper.filter(pt => pt.x >= CUTOVER_MS);
              if (cutY !== null) {
                lowerBand = [{ x: CUTOVER_MS, y: cutY }, ...lowerBand];
                upperBand = [{ x: CUTOVER_MS, y: cutY }, ...upperBand];
              }
              const lowerDs = {
                label: '', // no label; hide from legend/tooltip
                data: lowerBand,
                borderColor: 'transparent',
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 0,
                tension: 0.2,
                fill: false
              };
              const bandDs = {
                label: '95% confidence',
                data: upperBand,
                borderColor: 'transparent',
                backgroundColor: (colors.upper || '#e41a1c') + '33',
                pointRadius: 0,
                borderWidth: 0,
                tension: 0.2,
                fill: '-1' // fill to previous dataset (lower)
              };
              // Split middle into observed (<=2020-01-01) and predicted (>=2020-01-01)
              let observed = series.middle.map(pt => (pt.x <= CUTOVER_MS ? pt : { x: pt.x, y: null }));
              let predicted = series.middle.filter(pt => pt.x >= CUTOVER_MS);
              // Add bridging point at CUTOVER_MS so lines meet without a gap
              const prevPt = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
              const hasCutoverObserved = observed.some(pt => pt.x === CUTOVER_MS && pt.y !== null);
              const hasCutoverPred = predicted.some(pt => pt.x === CUTOVER_MS);
              if (prevPt) {
                const bridge = { x: CUTOVER_MS, y: prevPt.y };
                if (!hasCutoverObserved) observed = [...observed.filter(pt => pt.x < CUTOVER_MS), bridge, ...observed.filter(pt => pt.x > CUTOVER_MS)];
                if (!hasCutoverPred) predicted = [bridge, ...predicted];
              }
              // Ensure arrays sorted by x and nulls removed from predicted
              observed.sort((a,b) => a.x - b.x);
              predicted.sort((a,b) => a.x - b.x);
              const observedDs = {
                label: 'observed',
                data: observed,
                borderColor: colors.middle,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [],
                tension: 0.2,
                fill: false
              };
              const predictedDs = {
                label: 'predicted',
                data: predicted,
                borderColor: colors.middle,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [6, 4],
                tension: 0.2,
                fill: false
              };
              const datasets = [lowerDs, bandDs, observedDs, predictedDs];

              // Build or update Chart.js
              const ctx = document.getElementById('air-chart');
              if (ctx && window.Chart) {
                // Destroy any existing chart on this canvas before creating a new one
                try {
                  const existing = (window.Chart.getChart ? window.Chart.getChart(ctx) : window.airChart);
                  if (existing) existing.destroy();
                } catch (e) { console.warn('Chart destroy warning:', e); }

                window.airChart = new Chart(ctx, {
                  type: 'line',
                  data: { datasets },
                  options: {
                    maintainAspectRatio: false,
                    parsing: false,
                    spanGaps: true,
                    scales: {
                      x: {
                        type: 'linear',
                        title: { display: true, text: 'Date' },
                        min: START_MS,
                        max: END_MS,
                        ticks: {
                          callback: (v) => { try { return new Date(v).toISOString().slice(0,16).replace('T',' '); } catch { return v; } },
                          maxTicksLimit: 6
                        }
                      },
                      y: { title: { display: true, text: 'Human Modification Index' } }
                    },
                    plugins: {
                      legend: {
                        display: true,
                        labels: {
                          filter: (item) => !!item.text
                        }
                      },
                      tooltip: {
                        callbacks: {
                          label: (ctx) => {
                            const label = ctx.dataset && typeof ctx.dataset.label === 'string' ? ctx.dataset.label : '';
                            if (!label || label.startsWith('_')) return null; // hide helper/empty labels
                            const x = ctx.parsed.x; const y = ctx.parsed.y;
                            const ts = new Date(x).toISOString().slice(0,19).replace('T',' ');
                            return ` ${label}: ${y}  •  ${ts}`;
                          }
                        }
                      }
                    }
                  }
                });
              }
            })
            .catch(err => {
              // Hide spinner and log error, but do not show UI text
              edrEl.innerHTML = '';
              console.error('EDR error:', err);
            });
        }
      });
    }

    map.on('style.load', () => {
      // Switch to globe projection
      if (map.setProjection) {
        map.setProjection('globe');
      }

      // Build WMS URL from PARAM and YEAR selections
      const buildWmsUrl = (param, year) => {
        const base = 'https://compute.earthmover.io/v1/services/wms/the-nature-conservancy/hm-multitemp/main/hm/wms?version=1.3.0&service=WMS&request=GetMap&layers=PARAM&styles=raster/default&colorscalerange=0,1&width=512&height=512&crs=EPSG:3857&date=YEAR&tile={x},{y},{z}';
        return base.replace('PARAM', param).replace('YEAR', year);
      };

      // Insert below labels/buildings if present
      const beforeId = map.getStyle().layers.find(l => ['building','road-label','poi-label','place-label'].includes(l.id))?.id;

      // IDs for PARAM sources/layers
      const params = ['lower','middle','upper']; // bottom-first for stacking
      const srcId = (panel, p) => `wms-${panel}-${p}-src`;
      const lyrId = (panel, p) => `wms-${panel}-${p}-layer`;

      // Helper to (re)create a source+layer for a given panel, param and year
      function upsertParam(panel, param, year, opacity) {
        if (map.getLayer(lyrId(panel, param))) map.removeLayer(lyrId(panel, param));
        if (map.getSource(srcId(panel, param))) map.removeSource(srcId(panel, param));
        const url = buildWmsUrl(param, year);
        console.log(`[WMS] panel=${panel} param=${param} year=${year} url=`, url);
        map.addSource(srcId(panel, param), {
          type: 'raster',
          tiles: [ url ],
          tileSize: 256
        });
        map.addLayer({
          id: lyrId(panel, param),
          type: 'raster',
          source: srcId(panel, param),
          paint: { 'raster-opacity': opacity }
        }, beforeId);
      }

      // Initial creation for both panels based on current UI selections
      const yearSel1 = document.getElementById('mb-year-1');
      const yearSel2 = document.getElementById('mb-year-2');
      const opacity1El = document.getElementById('mb-opacity-1');
      const opacity2El = document.getElementById('mb-opacity-2');
      const op1 = opacity1El ? parseFloat(opacity1El.value) : 1.0;
      const op2 = opacity2El ? parseFloat(opacity2El.value) : 0.0;
      const yearVal1 = yearSel1 ? yearSel1.value : '1990-01-01';
      const yearVal2 = yearSel2 ? yearSel2.value : '1990-01-01';
      params.forEach(p => upsertParam(1, p, yearVal1, op1));
      params.forEach(p => upsertParam(2, p, yearVal2, op2));

      // Wire up PARAM radios per panel to enforce single selection and toggle visibility
      function setOnly(panel, param) {
        params.forEach(p => {
          const id = lyrId(panel, p);
          if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', p === param ? 'visible' : 'none');
        });
      }
      const paramRadios1 = Array.from(document.querySelectorAll('input[name="mb-param-1"]'));
      const paramRadios2 = Array.from(document.querySelectorAll('input[name="mb-param-2"]'));
      paramRadios1.forEach(r => r.addEventListener('change', () => setOnly(1, r.value)));
      paramRadios2.forEach(r => r.addEventListener('change', () => setOnly(2, r.value)));
      // Initial vis sync: show selected radio only per panel
      const selRadio1 = (paramRadios1.find(r => r.checked) || { value: 'upper' }).value;
      const selRadio2 = (paramRadios2.find(r => r.checked) || { value: 'upper' }).value;
      setOnly(1, selRadio1);
      setOnly(2, selRadio2);

      // On Year change, recreate sources for that panel and reapply selection and opacity
      if (yearSel1) {
        yearSel1.addEventListener('change', () => {
          const y = yearSel1.value;
          const op = opacity1El ? parseFloat(opacity1El.value) : 1.0;
          params.forEach(p => upsertParam(1, p, y, op));
          const sr = (paramRadios1.find(r => r.checked) || { value: 'upper' }).value;
          setOnly(1, sr);
        });
      }
      if (yearSel2) {
        yearSel2.addEventListener('change', () => {
          const y = yearSel2.value;
          const op = opacity2El ? parseFloat(opacity2El.value) : 0.0;
          params.forEach(p => upsertParam(2, p, y, op));
          const sr = (paramRadios2.find(r => r.checked) || { value: 'upper' }).value;
          setOnly(2, sr);
        });
      }

      // Opacity sliders wiring: update raster-opacity for all layers of that panel
      function setOpacity(panel, value) {
        params.forEach(p => {
          const id = lyrId(panel, p);
          if (map.getLayer(id)) map.setPaintProperty(id, 'raster-opacity', value);
        });
      }
      const op1Val = document.getElementById('mb-opacity-1-val');
      const op2Val = document.getElementById('mb-opacity-2-val');
      if (opacity1El) {
        opacity1El.addEventListener('input', () => {
          const v = parseFloat(opacity1El.value);
          if (op1Val) op1Val.textContent = v.toFixed(2);
          setOpacity(1, v);
        });
      }
      if (opacity2El) {
        opacity2El.addEventListener('input', () => {
          const v = parseFloat(opacity2El.value);
          if (op2Val) op2Val.textContent = v.toFixed(2);
          setOpacity(2, v);
        });
      }

      // Global map error logging for easier debugging
      map.on('error', (e) => {
        console.error('[Mapbox error]', e && e.error ? e.error : e);
      });

      // Add empty GeoJSON source/layer for click marker (above WMS, below labels if possible)
      if (!map.getSource('click-point')) {
        map.addSource('click-point', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });
      }
      if (!map.getLayer('click-point-layer')) {
        map.addLayer({
          id: 'click-point-layer',
          type: 'circle',
          source: 'click-point',
          paint: {
            'circle-radius': 6,
            'circle-color': '#e74c3c',
            'circle-stroke-color': '#ffffff',
            'circle-stroke-width': 1.5
          }
        }, beforeId);
      }

      // Resize nudges
      setTimeout(() => map.resize(), 200);
      requestAnimationFrame(() => map.resize());
    });
  }

  function maybeInitMbGlobeOnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#mb-globe')) {
      initMbGlobe();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMbGlobeOnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMbGlobeOnCurrentSlide);
    } else {
      initMbGlobe();
    }
  });
</script>


## Human modification forecast {.scrollable}

```{=html}
<link href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css" rel="stylesheet" />
<style>
  /* MapLibre panel styling for a cleaner look */
  .ml-controls { display:flex; flex-direction:column; gap:8px; margin-bottom:8px; font-size: 13px; }
  .ml-panel { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .ml-panel-title { font-weight:600; min-width:72px; font-size:13px; }
  .ml-panel label, .ml-panel span, .ml-panel select, .ml-panel small { font-size:13px; }
  .ml-chart-wrap { display:flex; justify-content:center; margin-top:10px; }
  .ml-chart-inner { width: 72vw; max-width: 980px; }
  #ml-edr { font-size:12px; color:#333; white-space:pre-wrap; text-align:center; margin-top:6px; }
  #ml-edr-chart { width:100%; height: 300px; max-height: 340px; }
  /* Tighten slider spacing */
  .ml-slider { display:flex; align-items:center; gap:8px; }
  .ml-spacer { flex:1; }
</style>
<div class="ml-controls">
  <div class="ml-panel">
    <div class="ml-panel-title">Top layer</div>
    <label for="pm-layer-select-1">Source:</label>
    <select id="pm-layer-select-1">
      <option value="obs1990" selected>Observed 1990</option>
      <option value="obs2020">Observed 2020</option>
      <option value="mean2040">Mean 2040</option>
      <option value="upper2040">Upper 2040</option>
      <option value="lower2040">Lower 2040</option>
    </select>
    <div class="ml-slider">
      <span>Opacity</span>
      <input type="range" id="pm-opacity-1" min="0" max="1" step="0.05" value="1">
      <span id="pm-opacity-1-val">1.00</span>
    </div>
  </div>
  <div class="ml-panel">
    <div class="ml-panel-title">Bottom layer</div>
    <label for="pm-layer-select-2">Source:</label>
    <select id="pm-layer-select-2">
      <option value="obs1990">Observed 1990</option>
      <option value="obs2020">Observed 2020</option>
      <option value="mean2040" selected>Mean 2040</option>
      <option value="upper2040">Upper 2040</option>
      <option value="lower2040">Lower 2040</option>
    </select>
    <div class="ml-slider">
      <span>Opacity</span>
      <input type="range" id="pm-opacity-2" min="0" max="1" step="0.05" value="0">
      <span id="pm-opacity-2-val">0.00</span>
    </div>
    <div class="ml-spacer"></div>
  </div>
</div>
<div id="ml-pmtiles-globe" style="height: 420px; margin-top: 0.5rem;"></div>
<div class="ml-chart-wrap">
  <div class="ml-chart-inner">
    <div id="ml-edr">Click on the map to fetch HM EDR time series…</div>
    <canvas id="ml-edr-chart"></canvas>
  </div>
</div>
```

<script src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3/dist/pmtiles.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
<script>
  let mlPmInited = false;
  let mlEdrChart = null;
  function initMlPmGlobe() {
    if (mlPmInited) return;
    mlPmInited = true;

    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }

    const protocol = new pmtiles.Protocol();
    if (typeof maplibregl.addProtocol === 'function') {
      maplibregl.addProtocol('pmtiles', protocol.tile);
    }

    // Minimal blank style; we'll add Esri + PMTiles sources/layers explicitly
    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map = new maplibregl.Map({
      container: 'ml-pmtiles-globe',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 1.8,
      attributionControl: true
    });

    map.on('style.load', () => {
      // MapLibre GL JS 5.x globe projection API
      try { map.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri World Imagery basemap (XYZ)
      const esriSrcId = 'esri-world';
      const esriLayerId = 'esri-world';
      if (!map.getSource(esriSrcId)) {
        map.addSource(esriSrcId, {
          type: 'raster',
          tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
          tileSize: 256,
          attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        });
      }
      if (!map.getLayer(esriLayerId)) {
        map.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });
      }

      // PMTiles datasets
      const PM_SOURCES = {
        obs1990: 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/obs1990_katie.pmtiles',
        obs2020: 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/obs2020_katie.pmtiles',
        mean2040: 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/mid2040_katie.pmtiles',
        upper2040: 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/upp2040_katie.pmtiles',
        lower2040: 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/low2040_katie.pmtiles'
      };
      const KEYS = Object.keys(PM_SOURCES);
      // Add sources for each dataset
      KEYS.forEach((k) => {
        const url = PM_SOURCES[k];
        if (!url) return; // skip missing
        const srcId = `pm-src-${k}`;
        if (!map.getSource(srcId)) {
          map.addSource(srcId, { type: 'raster', tiles: [`pmtiles://${url}/{z}/{x}/{y}`], tileSize: 512 });
        }
      });
      // Create per-panel layers for each dataset
      const LYR = { 1: {}, 2: {} };
      const ensureLayer = (panel, key) => {
        const srcId = `pm-src-${key}`;
        if (!PM_SOURCES[key]) return; // no source
        const id = `pm${panel}-${key}`;
        LYR[panel][key] = id;
        if (!map.getLayer(id)) {
          map.addLayer({ id, type: 'raster', source: srcId, paint: { 'raster-opacity': 1.0 } });
          map.setLayoutProperty(id, 'visibility', 'none');
        }
      };
      KEYS.forEach((k) => { ensureLayer(1, k); ensureLayer(2, k); });

      // Helpers to apply selection/opacity per panel
      function applySelection(panel, key) {
        KEYS.forEach((k) => {
          const id = LYR[panel][k];
          if (!id) return;
          try { map.setLayoutProperty(id, 'visibility', k === key ? 'visible' : 'none'); } catch (e) {}
        });
      }
      function applyOpacity(panel, value) {
        KEYS.forEach((k) => {
          const id = LYR[panel][k];
          if (!id) return;
          try { map.setPaintProperty(id, 'raster-opacity', value); } catch (e) {}
        });
      }

      // Wire UI controls
      const sel1 = document.getElementById('pm-layer-select-1');
      const sel2 = document.getElementById('pm-layer-select-2');
      const op1 = document.getElementById('pm-opacity-1');
      const op2 = document.getElementById('pm-opacity-2');
      const op1Val = document.getElementById('pm-opacity-1-val');
      const op2Val = document.getElementById('pm-opacity-2-val');

      // Initial state: Top per selection, Bottom per selection
      applySelection(1, sel1 ? sel1.value : 'obs1990');
      applySelection(2, sel2 ? sel2.value : 'mean2040');
      const initOp1 = op1 ? parseFloat(op1.value) : 1.0;
      const initOp2 = op2 ? parseFloat(op2.value) : 0.0;
      applyOpacity(1, initOp1);
      applyOpacity(2, initOp2);
      if (op1Val) op1Val.textContent = initOp1.toFixed(2);
      if (op2Val) op2Val.textContent = initOp2.toFixed(2);

      if (sel1) sel1.addEventListener('change', () => applySelection(1, sel1.value));
      if (sel2) sel2.addEventListener('change', () => applySelection(2, sel2.value));
      if (op1) op1.addEventListener('input', () => { const v = parseFloat(op1.value); if (op1Val) op1Val.textContent = v.toFixed(2); applyOpacity(1, v); });
      if (op2) op2.addEventListener('input', () => { const v = parseFloat(op2.value); if (op2Val) op2Val.textContent = v.toFixed(2); applyOpacity(2, v); });

      // EDR click handler (replicates Mapbox slide behavior)
      const edrEl = document.getElementById('ml-edr');
      const chartEl = document.getElementById('ml-edr-chart');
      const CUTOVER_MS = Date.UTC(2020, 0, 1);

      function ensureSpinnerCss() {
        if (!document.getElementById('edr-spinner-style')) {
          const style = document.createElement('style');
          style.id = 'edr-spinner-style';
          style.textContent = `
            .edr-spinner { display:inline-block; width:14px; height:14px; border:2px solid rgba(0,0,0,0.15); border-top-color: rgba(0,0,0,0.6); border-radius:50%; animation: edr-spin 0.8s linear infinite; vertical-align:middle; }
            @keyframes edr-spin { to { transform: rotate(360deg); } }
          `;
          document.head.appendChild(style);
        }
      }

      async function fetchEdrSeries(lng, lat) {
        ensureSpinnerCss();
        if (edrEl) edrEl.innerHTML = '<span class="edr-spinner" aria-label="Loading" title="Loading"></span>';
        const coordsWKT = `POINT(${lng} ${lat})`;
        const makeUrl = (param) => `https://compute.earthmover.io/v1/services/edr/the-nature-conservancy/hm-multitemp/main/hm/edr/position?coords=${encodeURIComponent(coordsWKT)}&parameter-name=${param}`;
        const paramsList = ['upper','middle','lower'];
        const results = await Promise.all(paramsList.map(p => fetch(makeUrl(p)).then(r => r.json()).then(data => ({ p, data })).catch(error => ({ p, error }))));

        const START_MS = Date.parse('1990-01-01');
        const CUTOVER_MS = Date.parse('2020-01-01');
        const END_MS = Date.parse('2040-01-01');

        const series = { upper: [], middle: [], lower: [] };
        results.forEach(({ p, data, error }) => {
          if (error || !data || !series[p]) return;
          const dates = data?.domain?.axes?.date?.values || data?.domain?.axes?.t?.values || [];
          const vals = data?.ranges?.[p]?.values || [];
          if (Array.isArray(dates) && Array.isArray(vals) && dates.length && vals.length) {
            series[p] = dates
              .map((d, i) => ({ x: Date.parse(d), y: vals[i] }))
              .filter(pt => Number.isFinite(pt.x) && Number.isFinite(pt.y) && pt.x >= START_MS && pt.x <= END_MS)
              .sort((a,b) => a.x - b.x);
          }
        });

        // Build confidence band arrays from CUTOVER forward, bridged at CUTOVER using middle value
        const lastObservedMiddle = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
        const cutY = lastObservedMiddle ? lastObservedMiddle.y : null;
        let lowerBand = series.lower.filter(pt => pt.x >= CUTOVER_MS);
        let upperBand = series.upper.filter(pt => pt.x >= CUTOVER_MS);
        if (cutY !== null) {
          lowerBand = [{ x: CUTOVER_MS, y: cutY }, ...lowerBand];
          upperBand = [{ x: CUTOVER_MS, y: cutY }, ...upperBand];
        }

        // Split middle into observed/predicted with bridging point
        let observed = series.middle.map(pt => (pt.x <= CUTOVER_MS ? pt : { x: pt.x, y: null }));
        let predicted = series.middle.filter(pt => pt.x >= CUTOVER_MS);
        const prevPt = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
        const hasCutObserved = observed.some(pt => pt.x === CUTOVER_MS && pt.y !== null);
        const hasCutPred = predicted.some(pt => pt.x === CUTOVER_MS);
        if (prevPt) {
          const bridge = { x: CUTOVER_MS, y: prevPt.y };
          if (!hasCutObserved) observed = [...observed.filter(pt => pt.x < CUTOVER_MS), bridge, ...observed.filter(pt => pt.x > CUTOVER_MS)];
          if (!hasCutPred) predicted = [bridge, ...predicted];
        }
        observed.sort((a,b) => a.x - b.x);
        predicted.sort((a,b) => a.x - b.x);

        return { series, lowerBand, upperBand, observed, predicted, START_MS, END_MS };
      }

      function renderChart(res) {
        const ctx = chartEl?.getContext('2d');
        if (!ctx) return;
        try { if (mlEdrChart) { mlEdrChart.destroy(); } } catch(_) {}
        mlEdrChart = null;

        const colors = { upper: '#e41a1c', middle: '#377eb8', lower: '#4daf4a' };
        const lowerDs = { label: '', data: res.lowerBand, borderColor: 'transparent', backgroundColor: 'transparent', pointRadius: 0, borderWidth: 0, tension: 0.2, fill: false };
        const bandDs = { label: '95% confidence', data: res.upperBand, borderColor: 'transparent', backgroundColor: (colors.upper || '#e41a1c') + '33', pointRadius: 0, borderWidth: 0, tension: 0.2, fill: '-1' };
        const observedDs = { label: 'observed', data: res.observed, borderColor: colors.middle, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, borderDash: [], tension: 0.2, fill: false };
        const predictedDs = { label: 'predicted', data: res.predicted, borderColor: colors.middle, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, borderDash: [6,4], tension: 0.2, fill: false };

        mlEdrChart = new Chart(ctx, {
          type: 'line',
          data: { datasets: [lowerDs, bandDs, observedDs, predictedDs] },
          options: {
            maintainAspectRatio: false,
            parsing: false,
            spanGaps: true,
            scales: {
              x: { type: 'linear', min: res.START_MS, max: res.END_MS, ticks: { maxTicksLimit: 6, callback: (v) => { try { return new Date(v).toISOString().slice(0, 4); } catch { return v; } } } },
              y: { title: { display: true, text: 'Human Modification Index' } }
            },
            plugins: {
              legend: { display: true, labels: { filter: (item) => !!item.text } },
              tooltip: { callbacks: { label: (ctx) => { const label = ctx.dataset && typeof ctx.dataset.label === 'string' ? ctx.dataset.label : ''; if (!label || label.startsWith('_')) return null; const x = ctx.parsed.x; const y = ctx.parsed.y; const ts = new Date(x).toISOString().slice(0,19).replace('T',' '); return ` ${label}: ${y}  •  ${ts}`; } } }
            }
          }
        });
      }

      // Click marker
      let clickMarker = null;
      map.on('click', async (e) => {
        const { lng, lat } = e.lngLat;
        try { if (clickMarker) { clickMarker.remove(); } } catch(_) {}
        clickMarker = new maplibregl.Marker({ color: '#e11d48', scale: 0.9 })
          .setLngLat([lng, lat])
          .addTo(map);
        try {
          const result = await fetchEdrSeries(lng, lat);
          if (edrEl) edrEl.textContent = `EDR at (${lng.toFixed(4)}, ${lat.toFixed(4)})`;
          renderChart(result);
        } catch (err) {
          if (edrEl) edrEl.textContent = 'EDR error';
          console.error('EDR error:', err);
        }
      });

      // Resize passes after layout transition
      setTimeout(() => map.resize(), 200);
      requestAnimationFrame(() => map.resize());
    });
  }

  function maybeInitMlPmOnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe')) {
      initMlPmGlobe();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPmOnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPmOnCurrentSlide);
    } else {
      initMlPmGlobe();
    }
  });
</script>

---

## Change in extent of intact lands

```{=html}
<style>
  /* Scoped styles for 2nd MapLibre legend (Inferno categories) */
  .ml2-map-wrap { position: relative; }
  .ml2-legend { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); }
  .ml2-legend-item { display:flex; align-items:center; gap:8px; margin:4px 0; }
  .ml2-swatch { width:14px; height:14px; border:1px solid rgba(0,0,0,0.4); border-radius:2px; }
  .ml2-ctrl { margin-top:6px; font-size:12px; display:flex; align-items:center; gap:8px; }
  .ml2-ctrl input[type="range"] { width:120px; }
  @media (max-width: 720px) { .ml2-legend { font-size:12px; } }
</style>
<div class="ml2-map-wrap">
  <div id="ml-pmtiles-globe-2" style="height: 460px; margin-top: 0.5rem;"></div>
  <div class="ml2-legend" aria-label="Map legend">
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#3b0f70;"></span><span>intact</span></div>
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#9c179e;"></span><span>converted 97.5%</span></div>
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#f98e09;"></span><span>converted 50%</span></div>
    <div class="ml2-legend-item"><span class="ml2-swatch" style="background:#fcffa4;"></span><span>converted 2.5%</span></div>
    <div class="ml2-ctrl">
      <span>Opacity</span>
      <input id="ml2-opacity" type="range" min="0" max="1" step="0.05" value="0.95" />
      <span id="ml2-opacity-val">0.95</span>
    </div>
  </div>
</div>
```

<script>
  let mlPm2Inited = false;
  function initMlPmGlobe2() {
    if (mlPm2Inited) return;
    mlPm2Inited = true;
    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }
    // Register pmtiles protocol (ignore if already registered)
    try {
      const protocol2 = new pmtiles.Protocol();
      if (typeof maplibregl.addProtocol === 'function') {
        try { maplibregl.addProtocol('pmtiles', protocol2.tile); } catch (_) {}
      }
    } catch (_) {}

    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map2 = new maplibregl.Map({
      container: 'ml-pmtiles-globe-2',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 2,
      attributionControl: true
    });

    map2.on('style.load', () => {
      try { map2.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri basemap
      const esriSrcId = 'esri-world-2';
      const esriLayerId = 'esri-world-2';
      map2.addSource(esriSrcId, {
        type: 'raster',
        tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        tileSize: 256,
        attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });
      map2.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });

      // PMTiles: show 'new' only
      const pmtilesNew = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/land_z0-7.pmtiles';
      const srcNewId = 'pmtiles-new-2';
      const layerNewId = 'pmtiles-new-2';
      map2.addSource(srcNewId, { type: 'raster', tiles: [`pmtiles://${pmtilesNew}/{z}/{x}/{y}`], tileSize: 512 });
      map2.addLayer({ id: layerNewId, type: 'raster', source: srcNewId, paint: { 'raster-opacity': 0.95 } });

      // Opacity slider wiring
      const op = document.getElementById('ml2-opacity');
      const opVal = document.getElementById('ml2-opacity-val');
      if (op) {
        const setOp = (v) => { try { map2.setPaintProperty(layerNewId, 'raster-opacity', v); if (opVal) opVal.textContent = (+v).toFixed(2); } catch(e) {} };
        setOp(parseFloat(op.value || '0.95'));
        op.addEventListener('input', () => setOp(parseFloat(op.value)));
      }

      // Resize nudges
      setTimeout(() => map2.resize(), 200);
      requestAnimationFrame(() => map2.resize());
    });
  }

  function maybeInitMlPm2OnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe-2')) {
      initMlPmGlobe2();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPm2OnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPm2OnCurrentSlide);
    } else {
      initMlPmGlobe2();
    }
  });
</script>

---

## HM increase 2020-2040

```{=html}
<style>
  /* Simple layout without legend */
  .ml3-wrap { position: relative; }
  .ml3-ctrl { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); display:flex; align-items:center; gap:8px; }
  .ml3-ctrl input[type="range"] { width:120px; }
  @media (max-width: 720px) { .ml3-ctrl { font-size:12px; } }
  </style>
<div class="ml3-wrap">
  <div id="ml-pmtiles-globe-3" style="height: 460px; margin-top: 0.5rem;"></div>
  <div class="ml3-ctrl" aria-label="Opacity control">
    <span>Opacity</span>
    <input id="ml3-opacity" type="range" min="0" max="1" step="0.05" value="0.95" />
    <span id="ml3-opacity-val">0.95</span>
  </div>
</div>
```

<script>
  let mlPm3Inited = false;
  function initMlPmGlobe3() {
    if (mlPm3Inited) return;
    mlPm3Inited = true;
    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }
    // Register pmtiles protocol (ignore if already registered)
    try {
      const protocol3 = new pmtiles.Protocol();
      if (typeof maplibregl.addProtocol === 'function') {
        try { maplibregl.addProtocol('pmtiles', protocol3.tile); } catch (_) {}
      }
    } catch (_) {}

    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map3 = new maplibregl.Map({
      container: 'ml-pmtiles-globe-3',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 2,
      attributionControl: true
    });

    map3.on('style.load', () => {
      try { map3.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri basemap
      const esriSrcId = 'esri-world-3';
      const esriLayerId = 'esri-world-3';
      map3.addSource(esriSrcId, {
        type: 'raster',
        tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        tileSize: 256,
        attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });
      map3.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });

      // PMTiles: HM increase 2020-2040
      const pmtilesUrl = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/diff2040.pmtiles';
      const srcId = 'pmtiles-low2040-3';
      const layerId = 'pmtiles-low2040-3';
      map3.addSource(srcId, { type: 'raster', tiles: [`pmtiles://${pmtilesUrl}/{z}/{x}/{y}`], tileSize: 512 });
      map3.addLayer({ id: layerId, type: 'raster', source: srcId, paint: { 'raster-opacity': 0.95 } });

      // Opacity slider wiring
      const op = document.getElementById('ml3-opacity');
      const opVal = document.getElementById('ml3-opacity-val');
      if (op) {
        const setOp = (v) => { try { map3.setPaintProperty(layerId, 'raster-opacity', v); if (opVal) opVal.textContent = (+v).toFixed(2); } catch(e) {} };
        setOp(parseFloat(op.value || '0.95'));
        op.addEventListener('input', () => setOp(parseFloat(op.value)));
      }

      // Resize nudges
      setTimeout(() => map3.resize(), 200);
      requestAnimationFrame(() => map3.resize());
    });
  }

  function maybeInitMlPm3OnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe-3')) {
      initMlPmGlobe3();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPm3OnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPm3OnCurrentSlide);
    } else {
      initMlPmGlobe3();
    }
  });
</script>

---

## Uncertainty in 2040

```{=html}
<style>
  /* Simple layout without legend (duplicate of HM increase) */
  .ml4-wrap { position: relative; }
  .ml4-ctrl { position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.94); padding:8px 10px; border-radius:4px; font-size:13px; box-shadow:0 1px 4px rgba(0,0,0,0.2); display:flex; align-items:center; gap:8px; }
  .ml4-ctrl input[type="range"] { width:120px; }
  @media (max-width: 720px) { .ml4-ctrl { font-size:12px; } }
  </style>
<div class="ml4-wrap">
  <div id="ml-pmtiles-globe-4" style="height: 460px; margin-top: 0.5rem;"></div>
  <div class="ml4-ctrl" aria-label="Opacity control">
    <span>Opacity</span>
    <input id="ml4-opacity" type="range" min="0" max="1" step="0.05" value="0.95" />
    <span id="ml4-opacity-val">0.95</span>
  </div>
</div>
```

<script>
  let mlPm4Inited = false;
  function initMlPmGlobe4() {
    if (mlPm4Inited) return;
    mlPm4Inited = true;
    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }
    // Register pmtiles protocol (ignore if already registered)
    try {
      const protocol4 = new pmtiles.Protocol();
      if (typeof maplibregl.addProtocol === 'function') {
        try { maplibregl.addProtocol('pmtiles', protocol4.tile); } catch (_) {}
      }
    } catch (_) {}

    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map4 = new maplibregl.Map({
      container: 'ml-pmtiles-globe-4',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 2,
      attributionControl: true
    });

    map4.on('style.load', () => {
      try { map4.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri basemap
      const esriSrcId = 'esri-world-4';
      const esriLayerId = 'esri-world-4';
      map4.addSource(esriSrcId, {
        type: 'raster',
        tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
        tileSize: 256,
        attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
      });
      map4.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });

      // PMTiles: duplicate of HM increase slide
      const pmtilesUrl = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/duplo_katie.pmtiles';
      const srcId = 'pmtiles-low2040-4';
      const layerId = 'pmtiles-low2040-4';
      map4.addSource(srcId, { type: 'raster', tiles: [`pmtiles://${pmtilesUrl}/{z}/{x}/{y}`], tileSize: 512 });
      map4.addLayer({ id: layerId, type: 'raster', source: srcId, paint: { 'raster-opacity': 0.95 } });

      // Opacity slider wiring
      const op = document.getElementById('ml4-opacity');
      const opVal = document.getElementById('ml4-opacity-val');
      if (op) {
        const setOp = (v) => { try { map4.setPaintProperty(layerId, 'raster-opacity', v); if (opVal) opVal.textContent = (+v).toFixed(2); } catch(e) {} };
        setOp(parseFloat(op.value || '0.95'));
        op.addEventListener('input', () => setOp(parseFloat(op.value)));
      }

      // Resize nudges
      setTimeout(() => map4.resize(), 200);
      requestAnimationFrame(() => map4.resize());
    });
  }

  function maybeInitMlPm4OnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe-4')) {
      initMlPmGlobe4();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPm4OnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPm4OnCurrentSlide);
    } else {
      initMlPmGlobe4();
    }
  });
</script>

---

## Downloads
Coming soon....

## Improvements
Hurricanes vs HM
<div style="font-size:0.7em">
Ensembles are needed for hurricane forecasts because a single average windspeed or rainfall hides the range of plausible outcomes. Different model runs (or slightly different starting conditions) can produce very different tracks, intensities and timing — and impacts (storm surge, rainfall) are highly nonlinear in windspeed. An ensemble shows the spread and probability of extreme outcomes so forecasters can communicate risk (e.g., “10% chance of hurricane-force winds here”) instead of a misleading single average number.

![](/images/hurricane.png)

The same logic applies to land-cover or human-impact forecasts: these systems are driven by many uncertain processes (policy choices, development, fires, climate) and small differences can lead to very different spatial outcomes. A mean map blurs alternative futures and can hide hotspots or tipping points; an ensemble of scenarios/models reveals where change is likely, how certain that is, and the tails that matter for planning and conservation.
</div>

## Questions

glenn.moncrieff@tnc.org
