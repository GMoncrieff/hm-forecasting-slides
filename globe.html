## Globe (Mapbox + WMS)


```{=html}
<link href="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.css" rel="stylesheet" />
<div id="mb-globe-wrap" style="position:relative;">
  <div id="mb-globe" style="height: 500px; margin-top: 1rem;"></div>
  <!-- Layer toggle controls: Panel 1 -->
  <div id="mb-layer-controls-1" style="position:absolute; right:10px; top:10px; z-index:1000; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; font-size:14px; box-shadow:0 1px 4px rgba(0,0,0,0.2); min-width: 220px;">
    <div style="font-weight:700; margin-bottom:6px;">Human Modification Index</div>
    <div style="font-weight:600; margin-bottom:4px;">Year</div>
    <div style="margin-bottom:6px;">
      <select id="mb-year-1" style="width:100%;">
        <option value="1990-01-01">1990</option>
        <option value="1995-01-01">1995</option>
        <option value="2000-01-01">2000</option>
        <option value="2005-01-01">2005</option>
        <option value="2010-01-01">2010</option>
        <option value="2015-01-01">2015</option>
        <option value="2020-01-01">2020</option>
        <option value="2025-01-01">2025</option>
        <option value="2030-01-01">2030</option>
        <option value="2035-01-01">2035</option>
        <option value="2040-01-01">2040</option>
      </select>
    </div>
    <div style="border-top: 1px solid #ddd; margin:6px 0;"></div>
    <div style="font-weight:600; margin-bottom:4px;">Quantile</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-upper" value="upper" checked> <span>upper</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-middle" value="middle"> <span>middle</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-1" id="mb1-param-lower" value="lower"> <span>lower</span></label>
    </div>
    <div style="margin-top:6px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <span>Opacity</span>
        <input type="range" id="mb-opacity-1" min="0" max="1" step="0.05" value="1">
        <span id="mb-opacity-1-val">1.00</span>
      </label>
    </div>
  </div>
  <!-- Layer toggle controls: Panel 2 -->
  <div id="mb-layer-controls-2" style="position:absolute; right:10px; top:170px; z-index:999; background:rgba(255,255,255,0.92); padding:8px 10px; border-radius:4px; font-size:14px; box-shadow:0 1px 4px rgba(0,0,0,0.2); min-width: 220px;">
    <div style="font-weight:700; margin-bottom:6px;">Human Modification Index</div>
    <div style="font-weight:600; margin-bottom:4px;">Year</div>
    <div style="margin-bottom:6px;">
      <select id="mb-year-2" style="width:100%;">
        <option value="1990-01-01">1990</option>
        <option value="1995-01-01">1995</option>
        <option value="2000-01-01">2000</option>
        <option value="2005-01-01">2005</option>
        <option value="2010-01-01">2010</option>
        <option value="2015-01-01">2015</option>
        <option value="2020-01-01">2020</option>
        <option value="2025-01-01">2025</option>
        <option value="2030-01-01">2030</option>
        <option value="2035-01-01">2035</option>
        <option value="2040-01-01">2040</option>
      </select>
    </div>
    <div style="border-top: 1px solid #ddd; margin:6px 0;"></div>
    <div style="font-weight:600; margin-bottom:4px;">Quantile</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap;">
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-upper" value="upper" checked> <span>upper</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-middle" value="middle"> <span>middle</span></label>
      <label style="display:inline-flex; align-items:center; gap:6px;"><input type="radio" name="mb-param-2" id="mb2-param-lower" value="lower"> <span>lower</span></label>
    </div>
    <div style="margin-top:6px;">
      <label style="display:flex; align-items:center; gap:8px;">
        <span>Opacity</span>
        <input type="range" id="mb-opacity-2" min="0" max="1" step="0.05" value="0">
        <span id="mb-opacity-2-val">0.00</span>
      </label>
    </div>
  </div>
  
  <!-- Click coords readout -->
  <div id="mb-coords" style="margin-top: 8px; font-size: 13px; color:#333;">
    Click on the globe to see lon/lat here.
  </div>
  <div id="mb-edr" style="margin-top: 6px; font-size: 12px; color:#333; white-space: pre-wrap;"></div>
  <!-- Air through time chart -->
  <div id="air-chart-wrap" style="height: 220px; margin-top: 8px; background: #fff; border: 1px solid #eee; border-radius: 4px; padding: 6px;">
    <canvas id="air-chart" height="200"></canvas>
  </div>
  
</div>
```

<link href="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.css" rel="stylesheet" />
<script src="https://api.mapbox.com/mapbox-gl-js/v3.9.3/mapbox-gl.js"></script>
<!-- Chart.js + date adapter for time scale -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.umd.min.js"></script>
<script>
  let mbGlobeInited = false;
  // Chart instance holder
  let airChart = null;
  function initMbGlobe() {
    if (mbGlobeInited) return;
    mbGlobeInited = true;

    // Expect token set globally as window.MAPBOX_TOKEN; no hardcoded fallback
    if (window.MAPBOX_TOKEN) {
      mapboxgl.accessToken = window.MAPBOX_TOKEN;
    } else {
      console.warn('Mapbox token missing. Set MAPBOX_TOKEN env var before rendering the Mapbox globe slide.');
    }

    const map = new mapboxgl.Map({
      container: 'mb-globe',
      style: 'mapbox://styles/mapbox/satellite-streets-v12',
      zoom: 1,
      center: [-74.5447, 40.6892],
      attributionControl: true
    });

    // Show last-clicked lon/lat under the globe and drop/update a marker
    const coordEl = document.getElementById('mb-coords');
    function fmt(n) { return (Math.round(n * 10000) / 10000).toFixed(4); }
    if (coordEl) {
      map.on('click', (e) => {
        const { lng, lat } = e.lngLat;
        coordEl.textContent = `Lon: ${fmt(lng)}, Lat: ${fmt(lat)}`;
        // Update click-point GeoJSON source if present
        const src = map.getSource('click-point');
        if (src) {
          src.setData({
            type: 'FeatureCollection',
            features: [
              {
                type: 'Feature',
                geometry: { type: 'Point', coordinates: [lng, lat] },
                properties: {}
              }
            ]
          });
        }

        // Fetch EDR for three quantiles and plot together
        const edrEl = document.getElementById('mb-edr');
        if (edrEl) {
          // Show a lightweight spinner while fetching
          if (!document.getElementById('edr-spinner-style')) {
            const style = document.createElement('style');
            style.id = 'edr-spinner-style';
            style.textContent = `
              .edr-spinner { display:inline-block; width:14px; height:14px; border:2px solid rgba(0,0,0,0.15); border-top-color: rgba(0,0,0,0.6); border-radius:50%; animation: edr-spin 0.8s linear infinite; vertical-align:middle; }
              @keyframes edr-spin { to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);
          }
          edrEl.innerHTML = '<span class="edr-spinner" aria-label="Loading" title="Loading"></span>';
          const coordsWKT = `POINT(${lng} ${lat})`;
          const makeUrl = (param) => `https://compute.earthmover.io/v1/services/edr/the-nature-conservancy/hm-multitemp/main/hm/edr/position?coords=${encodeURIComponent(coordsWKT)}&parameter-name=${param}`;
          const paramsList = ['upper','middle','lower'];
          Promise.all(paramsList.map(p => fetch(makeUrl(p)).then(r => r.json()).then(data => ({ p, data })).catch(err => ({ p, error: err }))))
            .then(results => {
              // Collect points per param within date window
              const colors = { upper: '#e41a1c', middle: '#377eb8', lower: '#4daf4a' };
              const series = { upper: [], middle: [], lower: [] };
              const START_MS = Date.parse('1990-01-01');
              const CUTOVER_MS = Date.parse('2020-01-01');
              const END_MS = Date.parse('2040-01-01');
              let firstText = '';
              results.forEach(({ p, data, error }) => {
                if (error || !data || !series[p]) return;
                const dates = data?.domain?.axes?.date?.values || data?.domain?.axes?.t?.values || [];
                const vals = data?.ranges?.[p]?.values || [];
                if (Array.isArray(dates) && Array.isArray(vals) && dates.length && vals.length) {
                  series[p] = dates
                    .map((d, i) => ({ x: Date.parse(d), y: vals[i] }))
                    .filter(pt => Number.isFinite(pt.x) && Number.isFinite(pt.y) && pt.x >= START_MS && pt.x <= END_MS);
                  if (!firstText) firstText = `Date: ${dates[0]}  â€¢  ${p}: ${vals[0]}`;
                }
              });
              // Stop showing spinner regardless of whether data was found
              edrEl.innerHTML = '';

              // Build datasets: shaded 95% confidence (upper to lower), plus middle as observed/predicted
              // Make the confidence band converge to a single point at the last observed year (CUTOVER_MS)
              // using the middle series value at CUTOVER_MS, then expand from first forecast year (e.g., 2025).
              const lastObservedMiddle = [...series.middle]
                .filter(pt => pt.x <= CUTOVER_MS)
                .sort((a,b) => a.x - b.x)
                .slice(-1)[0];
              const cutY = lastObservedMiddle ? lastObservedMiddle.y : null;
              let lowerBand = series.lower.filter(pt => pt.x >= CUTOVER_MS);
              let upperBand = series.upper.filter(pt => pt.x >= CUTOVER_MS);
              if (cutY !== null) {
                lowerBand = [{ x: CUTOVER_MS, y: cutY }, ...lowerBand];
                upperBand = [{ x: CUTOVER_MS, y: cutY }, ...upperBand];
              }
              const lowerDs = {
                label: '', // no label; hide from legend/tooltip
                data: lowerBand,
                borderColor: 'transparent',
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 0,
                tension: 0.2,
                fill: false
              };
              const bandDs = {
                label: '95% confidence',
                data: upperBand,
                borderColor: 'transparent',
                backgroundColor: (colors.upper || '#e41a1c') + '33',
                pointRadius: 0,
                borderWidth: 0,
                tension: 0.2,
                fill: '-1' // fill to previous dataset (lower)
              };
              // Split middle into observed (<=2020-01-01) and predicted (>=2020-01-01)
              let observed = series.middle.map(pt => (pt.x <= CUTOVER_MS ? pt : { x: pt.x, y: null }));
              let predicted = series.middle.filter(pt => pt.x >= CUTOVER_MS);
              // Add bridging point at CUTOVER_MS so lines meet without a gap
              const prevPt = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
              const hasCutoverObserved = observed.some(pt => pt.x === CUTOVER_MS && pt.y !== null);
              const hasCutoverPred = predicted.some(pt => pt.x === CUTOVER_MS);
              if (prevPt) {
                const bridge = { x: CUTOVER_MS, y: prevPt.y };
                if (!hasCutoverObserved) observed = [...observed.filter(pt => pt.x < CUTOVER_MS), bridge, ...observed.filter(pt => pt.x > CUTOVER_MS)];
                if (!hasCutoverPred) predicted = [bridge, ...predicted];
              }
              // Ensure arrays sorted by x and nulls removed from predicted
              observed.sort((a,b) => a.x - b.x);
              predicted.sort((a,b) => a.x - b.x);
              const observedDs = {
                label: 'observed',
                data: observed,
                borderColor: colors.middle,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [],
                tension: 0.2,
                fill: false
              };
              const predictedDs = {
                label: 'predicted',
                data: predicted,
                borderColor: colors.middle,
                backgroundColor: 'transparent',
                pointRadius: 0,
                borderWidth: 2,
                borderDash: [6, 4],
                tension: 0.2,
                fill: false
              };
              const datasets = [lowerDs, bandDs, observedDs, predictedDs];

              // Build or update Chart.js
              const ctx = document.getElementById('air-chart');
              if (ctx && window.Chart) {
                // Destroy any existing chart on this canvas before creating a new one
                try {
                  const existing = (window.Chart.getChart ? window.Chart.getChart(ctx) : window.airChart);
                  if (existing) existing.destroy();
                } catch (e) { console.warn('Chart destroy warning:', e); }

                window.airChart = new Chart(ctx, {
                  type: 'line',
                  data: { datasets },
                  options: {
                    maintainAspectRatio: false,
                    parsing: false,
                    spanGaps: true,
                    scales: {
                      x: {
                        type: 'linear',
                        title: { display: true, text: 'Date' },
                        min: START_MS,
                        max: END_MS,
                        ticks: {
                          callback: (v) => { try { return new Date(v).toISOString().slice(0,16).replace('T',' '); } catch { return v; } },
                          maxTicksLimit: 6
                        }
                      },
                      y: { title: { display: true, text: 'Human Modification Index' } }
                    },
                    plugins: {
                      legend: {
                        display: true,
                        labels: {
                          filter: (item) => !!item.text
                        }
                      },
                      tooltip: {
                        callbacks: {
                          label: (ctx) => {
                            const label = ctx.dataset && typeof ctx.dataset.label === 'string' ? ctx.dataset.label : '';
                            if (!label || label.startsWith('_')) return null; // hide helper/empty labels
                            const x = ctx.parsed.x; const y = ctx.parsed.y;
                            const ts = new Date(x).toISOString().slice(0,19).replace('T',' ');
                            return ` ${label}: ${y}  â€¢  ${ts}`;
                          }
                        }
                      }
                    }
                  }
                });
              }
            })
            .catch(err => {
              // Hide spinner and log error, but do not show UI text
              edrEl.innerHTML = '';
              console.error('EDR error:', err);
            });
        }
      });
    }

    map.on('style.load', () => {
      // Switch to globe projection
      if (map.setProjection) {
        map.setProjection('globe');
      }

      // Build WMS URL from PARAM and YEAR selections
      const buildWmsUrl = (param, year) => {
        const base = 'https://compute.earthmover.io/v1/services/wms/the-nature-conservancy/hm-multitemp/main/hm/wms?version=1.3.0&service=WMS&request=GetMap&layers=PARAM&styles=raster/default&colorscalerange=0,1&width=512&height=512&crs=EPSG:3857&date=YEAR&tile={x},{y},{z}';
        return base.replace('PARAM', param).replace('YEAR', year);
      };

      // Insert below labels/buildings if present
      const beforeId = map.getStyle().layers.find(l => ['building','road-label','poi-label','place-label'].includes(l.id))?.id;

      // IDs for PARAM sources/layers
      const params = ['lower','middle','upper']; // bottom-first for stacking
      const srcId = (panel, p) => `wms-${panel}-${p}-src`;
      const lyrId = (panel, p) => `wms-${panel}-${p}-layer`;

      // Helper to (re)create a source+layer for a given panel, param and year
      function upsertParam(panel, param, year, opacity) {
        if (map.getLayer(lyrId(panel, param))) map.removeLayer(lyrId(panel, param));
        if (map.getSource(srcId(panel, param))) map.removeSource(srcId(panel, param));
        const url = buildWmsUrl(param, year);
        console.log(`[WMS] panel=${panel} param=${param} year=${year} url=`, url);
        map.addSource(srcId(panel, param), {
          type: 'raster',
          tiles: [ url ],
          tileSize: 256
        });
        map.addLayer({
          id: lyrId(panel, param),
          type: 'raster',
          source: srcId(panel, param),
          paint: { 'raster-opacity': opacity }
        }, beforeId);
      }

      // Initial creation for both panels based on current UI selections
      const yearSel1 = document.getElementById('mb-year-1');
      const yearSel2 = document.getElementById('mb-year-2');
      const opacity1El = document.getElementById('mb-opacity-1');
      const opacity2El = document.getElementById('mb-opacity-2');
      const op1 = opacity1El ? parseFloat(opacity1El.value) : 1.0;
      const op2 = opacity2El ? parseFloat(opacity2El.value) : 0.0;
      const yearVal1 = yearSel1 ? yearSel1.value : '1990-01-01';
      const yearVal2 = yearSel2 ? yearSel2.value : '1990-01-01';
      params.forEach(p => upsertParam(1, p, yearVal1, op1));
      params.forEach(p => upsertParam(2, p, yearVal2, op2));

      // Wire up PARAM radios per panel to enforce single selection and toggle visibility
      function setOnly(panel, param) {
        params.forEach(p => {
          const id = lyrId(panel, p);
          if (map.getLayer(id)) map.setLayoutProperty(id, 'visibility', p === param ? 'visible' : 'none');
        });
      }
      const paramRadios1 = Array.from(document.querySelectorAll('input[name="mb-param-1"]'));
      const paramRadios2 = Array.from(document.querySelectorAll('input[name="mb-param-2"]'));
      paramRadios1.forEach(r => r.addEventListener('change', () => setOnly(1, r.value)));
      paramRadios2.forEach(r => r.addEventListener('change', () => setOnly(2, r.value)));
      // Initial vis sync: show selected radio only per panel
      const selRadio1 = (paramRadios1.find(r => r.checked) || { value: 'upper' }).value;
      const selRadio2 = (paramRadios2.find(r => r.checked) || { value: 'upper' }).value;
      setOnly(1, selRadio1);
      setOnly(2, selRadio2);

      // On Year change, recreate sources for that panel and reapply selection and opacity
      if (yearSel1) {
        yearSel1.addEventListener('change', () => {
          const y = yearSel1.value;
          const op = opacity1El ? parseFloat(opacity1El.value) : 1.0;
          params.forEach(p => upsertParam(1, p, y, op));
          const sr = (paramRadios1.find(r => r.checked) || { value: 'upper' }).value;
          setOnly(1, sr);
        });
      }
      if (yearSel2) {
        yearSel2.addEventListener('change', () => {
          const y = yearSel2.value;
          const op = opacity2El ? parseFloat(opacity2El.value) : 0.0;
          params.forEach(p => upsertParam(2, p, y, op));
          const sr = (paramRadios2.find(r => r.checked) || { value: 'upper' }).value;
          setOnly(2, sr);
        });
      }

      // Opacity sliders wiring: update raster-opacity for all layers of that panel
      function setOpacity(panel, value) {
        params.forEach(p => {
          const id = lyrId(panel, p);
          if (map.getLayer(id)) map.setPaintProperty(id, 'raster-opacity', value);
        });
      }
      const op1Val = document.getElementById('mb-opacity-1-val');
      const op2Val = document.getElementById('mb-opacity-2-val');
      if (opacity1El) {
        opacity1El.addEventListener('input', () => {
          const v = parseFloat(opacity1El.value);
          if (op1Val) op1Val.textContent = v.toFixed(2);
          setOpacity(1, v);
        });
      }
      if (opacity2El) {
        opacity2El.addEventListener('input', () => {
          const v = parseFloat(opacity2El.value);
          if (op2Val) op2Val.textContent = v.toFixed(2);
          setOpacity(2, v);
        });
      }

      // Global map error logging for easier debugging
      map.on('error', (e) => {
        console.error('[Mapbox error]', e && e.error ? e.error : e);
      });

      // Add empty GeoJSON source/layer for click marker (above WMS, below labels if possible)
      if (!map.getSource('click-point')) {
        map.addSource('click-point', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });
      }
      if (!map.getLayer('click-point-layer')) {
        map.addLayer({
          id: 'click-point-layer',
          type: 'circle',
          source: 'click-point',
          paint: {
            'circle-radius': 6,
            'circle-color': '#e74c3c',
            'circle-stroke-color': '#ffffff',
            'circle-stroke-width': 1.5
          }
        }, beforeId);
      }

      // Resize nudges
      setTimeout(() => map.resize(), 200);
      requestAnimationFrame(() => map.resize());
    });
  }

  function maybeInitMbGlobeOnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#mb-globe')) {
      initMbGlobe();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMbGlobeOnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMbGlobeOnCurrentSlide);
    } else {
      initMbGlobe();
    }
  });
</script>
-->


## Globe (MapLibre + PMTiles) {.scrollable}

```{=html}
<link href="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.css" rel="stylesheet" />
<style>
  /* MapLibre panel styling for a cleaner look */
  .ml-controls { display:flex; flex-direction:column; gap:8px; margin-bottom:8px; font-size: 13px; }
  .ml-panel { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .ml-panel-title { font-weight:600; min-width:72px; font-size:13px; }
  .ml-panel label, .ml-panel span, .ml-panel select, .ml-panel small { font-size:13px; }
  .ml-chart-wrap { display:flex; justify-content:center; margin-top:10px; }
  .ml-chart-inner { width: 72vw; max-width: 980px; }
  #ml-edr { font-size:12px; color:#333; white-space:pre-wrap; text-align:center; margin-top:6px; }
  #ml-edr-chart { width:100%; height: 300px; max-height: 340px; }
  /* Tighten slider spacing */
  .ml-slider { display:flex; align-items:center; gap:8px; }
  .ml-spacer { flex:1; }
</style>
<div class="ml-controls">
  <div class="ml-panel">
    <div class="ml-panel-title">Layer A</div>
    <label for="pm-layer-select-1">Source:</label>
    <select id="pm-layer-select-1">
      <option value="old" selected>old</option>
      <option value="new">new</option>
    </select>
    <div class="ml-slider">
      <span>Opacity</span>
      <input type="range" id="pm-opacity-1" min="0" max="1" step="0.05" value="1">
      <span id="pm-opacity-1-val">1.00</span>
    </div>
  </div>
  <div class="ml-panel">
    <div class="ml-panel-title">Layer B</div>
    <label for="pm-layer-select-2">Source:</label>
    <select id="pm-layer-select-2">
      <option value="old">old</option>
      <option value="new" selected>new</option>
    </select>
    <div class="ml-slider">
      <span>Opacity</span>
      <input type="range" id="pm-opacity-2" min="0" max="1" step="0.05" value="0">
      <span id="pm-opacity-2-val">0.00</span>
    </div>
    <div class="ml-spacer"></div>
    <small>PMTiles from provided URL; both selectors reference the same dataset family.</small>
  </div>
</div>
<div id="ml-pmtiles-globe" style="height: 420px; margin-top: 0.5rem;"></div>
<div class="ml-chart-wrap">
  <div class="ml-chart-inner">
    <div id="ml-edr">Click on the map to fetch HM EDR time seriesâ€¦</div>
    <canvas id="ml-edr-chart"></canvas>
  </div>
</div>
```

<script src="https://unpkg.com/maplibre-gl@5.0.0/dist/maplibre-gl.js"></script>
<script src="https://unpkg.com/pmtiles@3/dist/pmtiles.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>
<script>
  let mlPmInited = false;
  let mlEdrChart = null;
  function initMlPmGlobe() {
    if (mlPmInited) return;
    mlPmInited = true;

    if (!window.maplibregl || !window.pmtiles) {
      console.error('MapLibre GL or PMTiles not loaded');
      return;
    }

    const protocol = new pmtiles.Protocol();
    if (typeof maplibregl.addProtocol === 'function') {
      maplibregl.addProtocol('pmtiles', protocol.tile);
    }

    // Minimal blank style; we'll add Esri + PMTiles sources/layers explicitly
    const blankStyle = { version: 8, sources: {}, layers: [], name: 'blank' };
    const map = new maplibregl.Map({
      container: 'ml-pmtiles-globe',
      style: blankStyle,
      center: [18.48, -33.8518],
      zoom: 1.8,
      attributionControl: true
    });

    map.on('style.load', () => {
      // MapLibre GL JS 5.x globe projection API
      try { map.setProjection({ type: 'globe' }); } catch (e) { console.warn('Globe projection not available:', e); }
      // Esri World Imagery basemap (XYZ)
      const esriSrcId = 'esri-world';
      const esriLayerId = 'esri-world';
      if (!map.getSource(esriSrcId)) {
        map.addSource(esriSrcId, {
          type: 'raster',
          tiles: ['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'],
          tileSize: 256,
          attribution: 'Esri, Maxar, Earthstar Geographics, and the GIS User Community'
        });
      }
      if (!map.getLayer(esriLayerId)) {
        map.addLayer({ id: esriLayerId, type: 'raster', source: esriSrcId });
      }

      // PMTiles raster sources: old and new
      const pmtilesOld = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/land_z0-8.pmtiles';
      const pmtilesNew = 'https://pub-6b6a1d5b041c4c749efaeb294cda9aac.r2.dev/land_z0-7.pmtiles';
      const srcOldId = 'pmtiles-old';
      const srcNewId = 'pmtiles-new';
      if (!map.getSource(srcOldId)) {
        map.addSource(srcOldId, { type: 'raster', tiles: [`pmtiles://${pmtilesOld}/{z}/{x}/{y}`], tileSize: 512 });
      }
      if (!map.getSource(srcNewId)) {
        map.addSource(srcNewId, { type: 'raster', tiles: [`pmtiles://${pmtilesNew}/{z}/{x}/{y}`], tileSize: 512 });
      }
      // Create four layers (two panels x two sources)
      const LYR = {
        1: { old: 'pm1-old', new: 'pm1-new' },
        2: { old: 'pm2-old', new: 'pm2-new' }
      };
      const ensureLayer = (id, source) => {
        if (!map.getLayer(id)) {
          map.addLayer({ id, type: 'raster', source, paint: { 'raster-opacity': 1.0 } });
        }
      };
      ensureLayer(LYR[1].old, srcOldId);
      ensureLayer(LYR[1].new, srcNewId);
      ensureLayer(LYR[2].old, srcOldId);
      ensureLayer(LYR[2].new, srcNewId);

      // Helpers to apply selection/opacity per panel
      function applySelection(panel, value) {
        const showOld = value === 'old';
        try {
          map.setLayoutProperty(LYR[panel].old, 'visibility', showOld ? 'visible' : 'none');
          map.setLayoutProperty(LYR[panel].new, 'visibility', showOld ? 'none' : 'visible');
        } catch (e) { console.warn('Layer toggle error', e); }
      }
      function applyOpacity(panel, value) {
        try {
          map.setPaintProperty(LYR[panel].old, 'raster-opacity', value);
          map.setPaintProperty(LYR[panel].new, 'raster-opacity', value);
        } catch (e) { console.warn('Opacity set error', e); }
      }

      // Wire UI controls
      const sel1 = document.getElementById('pm-layer-select-1');
      const sel2 = document.getElementById('pm-layer-select-2');
      const op1 = document.getElementById('pm-opacity-1');
      const op2 = document.getElementById('pm-opacity-2');
      const op1Val = document.getElementById('pm-opacity-1-val');
      const op2Val = document.getElementById('pm-opacity-2-val');

      // Initial state: A old @ 1.00, B new @ 0.00
      applySelection(1, sel1 ? sel1.value : 'old');
      applySelection(2, sel2 ? sel2.value : 'new');
      const initOp1 = op1 ? parseFloat(op1.value) : 1.0;
      const initOp2 = op2 ? parseFloat(op2.value) : 0.0;
      applyOpacity(1, initOp1);
      applyOpacity(2, initOp2);
      if (op1Val) op1Val.textContent = initOp1.toFixed(2);
      if (op2Val) op2Val.textContent = initOp2.toFixed(2);

      if (sel1) sel1.addEventListener('change', () => applySelection(1, sel1.value));
      if (sel2) sel2.addEventListener('change', () => applySelection(2, sel2.value));
      if (op1) op1.addEventListener('input', () => { const v = parseFloat(op1.value); if (op1Val) op1Val.textContent = v.toFixed(2); applyOpacity(1, v); });
      if (op2) op2.addEventListener('input', () => { const v = parseFloat(op2.value); if (op2Val) op2Val.textContent = v.toFixed(2); applyOpacity(2, v); });

      // EDR click handler (replicates Mapbox slide behavior)
      const edrEl = document.getElementById('ml-edr');
      const chartEl = document.getElementById('ml-edr-chart');
      const CUTOVER_MS = Date.UTC(2020, 0, 1);

      function ensureSpinnerCss() {
        if (!document.getElementById('edr-spinner-style')) {
          const style = document.createElement('style');
          style.id = 'edr-spinner-style';
          style.textContent = `
            .edr-spinner { display:inline-block; width:14px; height:14px; border:2px solid rgba(0,0,0,0.15); border-top-color: rgba(0,0,0,0.6); border-radius:50%; animation: edr-spin 0.8s linear infinite; vertical-align:middle; }
            @keyframes edr-spin { to { transform: rotate(360deg); } }
          `;
          document.head.appendChild(style);
        }
      }

      async function fetchEdrSeries(lng, lat) {
        ensureSpinnerCss();
        if (edrEl) edrEl.innerHTML = '<span class="edr-spinner" aria-label="Loading" title="Loading"></span>';
        const coordsWKT = `POINT(${lng} ${lat})`;
        const makeUrl = (param) => `https://compute.earthmover.io/v1/services/edr/the-nature-conservancy/hm-multitemp/main/hm/edr/position?coords=${encodeURIComponent(coordsWKT)}&parameter-name=${param}`;
        const paramsList = ['upper','middle','lower'];
        const results = await Promise.all(paramsList.map(p => fetch(makeUrl(p)).then(r => r.json()).then(data => ({ p, data })).catch(error => ({ p, error }))));

        const START_MS = Date.parse('1990-01-01');
        const CUTOVER_MS = Date.parse('2020-01-01');
        const END_MS = Date.parse('2040-01-01');

        const series = { upper: [], middle: [], lower: [] };
        results.forEach(({ p, data, error }) => {
          if (error || !data || !series[p]) return;
          const dates = data?.domain?.axes?.date?.values || data?.domain?.axes?.t?.values || [];
          const vals = data?.ranges?.[p]?.values || [];
          if (Array.isArray(dates) && Array.isArray(vals) && dates.length && vals.length) {
            series[p] = dates
              .map((d, i) => ({ x: Date.parse(d), y: vals[i] }))
              .filter(pt => Number.isFinite(pt.x) && Number.isFinite(pt.y) && pt.x >= START_MS && pt.x <= END_MS)
              .sort((a,b) => a.x - b.x);
          }
        });

        // Build confidence band arrays from CUTOVER forward, bridged at CUTOVER using middle value
        const lastObservedMiddle = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
        const cutY = lastObservedMiddle ? lastObservedMiddle.y : null;
        let lowerBand = series.lower.filter(pt => pt.x >= CUTOVER_MS);
        let upperBand = series.upper.filter(pt => pt.x >= CUTOVER_MS);
        if (cutY !== null) {
          lowerBand = [{ x: CUTOVER_MS, y: cutY }, ...lowerBand];
          upperBand = [{ x: CUTOVER_MS, y: cutY }, ...upperBand];
        }

        // Split middle into observed/predicted with bridging point
        let observed = series.middle.map(pt => (pt.x <= CUTOVER_MS ? pt : { x: pt.x, y: null }));
        let predicted = series.middle.filter(pt => pt.x >= CUTOVER_MS);
        const prevPt = [...series.middle].filter(pt => pt.x <= CUTOVER_MS).sort((a,b) => a.x - b.x).slice(-1)[0];
        const hasCutObserved = observed.some(pt => pt.x === CUTOVER_MS && pt.y !== null);
        const hasCutPred = predicted.some(pt => pt.x === CUTOVER_MS);
        if (prevPt) {
          const bridge = { x: CUTOVER_MS, y: prevPt.y };
          if (!hasCutObserved) observed = [...observed.filter(pt => pt.x < CUTOVER_MS), bridge, ...observed.filter(pt => pt.x > CUTOVER_MS)];
          if (!hasCutPred) predicted = [bridge, ...predicted];
        }
        observed.sort((a,b) => a.x - b.x);
        predicted.sort((a,b) => a.x - b.x);

        return { series, lowerBand, upperBand, observed, predicted, START_MS, END_MS };
      }

      function renderChart(res) {
        const ctx = chartEl?.getContext('2d');
        if (!ctx) return;
        try { if (mlEdrChart) { mlEdrChart.destroy(); } } catch(_) {}
        mlEdrChart = null;

        const colors = { upper: '#e41a1c', middle: '#377eb8', lower: '#4daf4a' };
        const lowerDs = { label: '', data: res.lowerBand, borderColor: 'transparent', backgroundColor: 'transparent', pointRadius: 0, borderWidth: 0, tension: 0.2, fill: false };
        const bandDs = { label: '95% confidence', data: res.upperBand, borderColor: 'transparent', backgroundColor: (colors.upper || '#e41a1c') + '33', pointRadius: 0, borderWidth: 0, tension: 0.2, fill: '-1' };
        const observedDs = { label: 'observed', data: res.observed, borderColor: colors.middle, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, borderDash: [], tension: 0.2, fill: false };
        const predictedDs = { label: 'predicted', data: res.predicted, borderColor: colors.middle, backgroundColor: 'transparent', pointRadius: 0, borderWidth: 2, borderDash: [6,4], tension: 0.2, fill: false };

        mlEdrChart = new Chart(ctx, {
          type: 'line',
          data: { datasets: [lowerDs, bandDs, observedDs, predictedDs] },
          options: {
            maintainAspectRatio: false,
            parsing: false,
            spanGaps: true,
            scales: {
              x: { type: 'linear', min: res.START_MS, max: res.END_MS, ticks: { maxTicksLimit: 6, callback: (v) => { try { return new Date(v).toISOString().slice(0, 4); } catch { return v; } } } },
              y: { title: { display: true, text: 'Human Modification Index' } }
            },
            plugins: {
              legend: { display: true, labels: { filter: (item) => !!item.text } },
              tooltip: { callbacks: { label: (ctx) => { const label = ctx.dataset && typeof ctx.dataset.label === 'string' ? ctx.dataset.label : ''; if (!label || label.startsWith('_')) return null; const x = ctx.parsed.x; const y = ctx.parsed.y; const ts = new Date(x).toISOString().slice(0,19).replace('T',' '); return ` ${label}: ${y}  â€¢  ${ts}`; } } }
            }
          }
        });
      }

      // Click marker
      let clickMarker = null;
      map.on('click', async (e) => {
        const { lng, lat } = e.lngLat;
        try { if (clickMarker) { clickMarker.remove(); } } catch(_) {}
        clickMarker = new maplibregl.Marker({ color: '#e11d48', scale: 0.9 })
          .setLngLat([lng, lat])
          .addTo(map);
        try {
          const result = await fetchEdrSeries(lng, lat);
          if (edrEl) edrEl.textContent = `EDR at (${lng.toFixed(4)}, ${lat.toFixed(4)})`;
          renderChart(result);
        } catch (err) {
          if (edrEl) edrEl.textContent = 'EDR error';
          console.error('EDR error:', err);
        }
      });

      // Resize passes after layout transition
      setTimeout(() => map.resize(), 200);
      requestAnimationFrame(() => map.resize());
    });
  }

  function maybeInitMlPmOnCurrentSlide() {
    const current = window.Reveal && Reveal.getCurrentSlide ? Reveal.getCurrentSlide() : null;
    if (current && current.querySelector('#ml-pmtiles-globe')) {
      initMlPmGlobe();
    }
  }

  document.addEventListener('DOMContentLoaded', () => {
    if (window.Reveal) {
      Reveal.on('ready', maybeInitMlPmOnCurrentSlide);
      Reveal.on('slidechanged', maybeInitMlPmOnCurrentSlide);
    } else {
      initMlPmGlobe();
    }
  });
</script>

---